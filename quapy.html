<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>quapy package &mdash; QuaPy: A Python-based open-source framework for quantification 0.1.9 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=8618f531"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="quapy.classification package" href="quapy.classification.html" />
    <link rel="prev" title="7. Protocols" href="manuals/protocols.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            QuaPy: A Python-based open-source framework for quantification
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Quickstart</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="manuals.html">Manuals</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html">quapy.classification package</a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html">quapy.data package</a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html">quapy.method package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-quapy.error">quapy.error module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.absolute_error"><code class="docutils literal notranslate"><span class="pre">absolute_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.acc_error"><code class="docutils literal notranslate"><span class="pre">acc_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.acce"><code class="docutils literal notranslate"><span class="pre">acce()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.ae"><code class="docutils literal notranslate"><span class="pre">ae()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.f1_error"><code class="docutils literal notranslate"><span class="pre">f1_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.f1e"><code class="docutils literal notranslate"><span class="pre">f1e()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.from_name"><code class="docutils literal notranslate"><span class="pre">from_name()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.kld"><code class="docutils literal notranslate"><span class="pre">kld()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.mae"><code class="docutils literal notranslate"><span class="pre">mae()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.match_distance"><code class="docutils literal notranslate"><span class="pre">match_distance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.md"><code class="docutils literal notranslate"><span class="pre">md()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.mean_absolute_error"><code class="docutils literal notranslate"><span class="pre">mean_absolute_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.mean_normalized_absolute_error"><code class="docutils literal notranslate"><span class="pre">mean_normalized_absolute_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.mean_normalized_relative_absolute_error"><code class="docutils literal notranslate"><span class="pre">mean_normalized_relative_absolute_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.mean_relative_absolute_error"><code class="docutils literal notranslate"><span class="pre">mean_relative_absolute_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.mkld"><code class="docutils literal notranslate"><span class="pre">mkld()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.mnae"><code class="docutils literal notranslate"><span class="pre">mnae()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.mnkld"><code class="docutils literal notranslate"><span class="pre">mnkld()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.mnrae"><code class="docutils literal notranslate"><span class="pre">mnrae()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.mrae"><code class="docutils literal notranslate"><span class="pre">mrae()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.mse"><code class="docutils literal notranslate"><span class="pre">mse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.nae"><code class="docutils literal notranslate"><span class="pre">nae()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.nkld"><code class="docutils literal notranslate"><span class="pre">nkld()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.nmd"><code class="docutils literal notranslate"><span class="pre">nmd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.normalized_absolute_error"><code class="docutils literal notranslate"><span class="pre">normalized_absolute_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.normalized_match_distance"><code class="docutils literal notranslate"><span class="pre">normalized_match_distance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.normalized_relative_absolute_error"><code class="docutils literal notranslate"><span class="pre">normalized_relative_absolute_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.nrae"><code class="docutils literal notranslate"><span class="pre">nrae()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.rae"><code class="docutils literal notranslate"><span class="pre">rae()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.relative_absolute_error"><code class="docutils literal notranslate"><span class="pre">relative_absolute_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.se"><code class="docutils literal notranslate"><span class="pre">se()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.error.smooth"><code class="docutils literal notranslate"><span class="pre">smooth()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quapy.evaluation">quapy.evaluation module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quapy.evaluation.evaluate"><code class="docutils literal notranslate"><span class="pre">evaluate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.evaluation.evaluate_on_samples"><code class="docutils literal notranslate"><span class="pre">evaluate_on_samples()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.evaluation.evaluation_report"><code class="docutils literal notranslate"><span class="pre">evaluation_report()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.evaluation.prediction"><code class="docutils literal notranslate"><span class="pre">prediction()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quapy.functional">quapy.functional module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.HellingerDistance"><code class="docutils literal notranslate"><span class="pre">HellingerDistance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.TopsoeDistance"><code class="docutils literal notranslate"><span class="pre">TopsoeDistance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.argmin_prevalence"><code class="docutils literal notranslate"><span class="pre">argmin_prevalence()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.as_binary_prevalence"><code class="docutils literal notranslate"><span class="pre">as_binary_prevalence()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.check_prevalence_vector"><code class="docutils literal notranslate"><span class="pre">check_prevalence_vector()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.clip"><code class="docutils literal notranslate"><span class="pre">clip()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.condsoftmax"><code class="docutils literal notranslate"><span class="pre">condsoftmax()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.counts_from_labels"><code class="docutils literal notranslate"><span class="pre">counts_from_labels()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.get_divergence"><code class="docutils literal notranslate"><span class="pre">get_divergence()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.get_nprevpoints_approximation"><code class="docutils literal notranslate"><span class="pre">get_nprevpoints_approximation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.l1_norm"><code class="docutils literal notranslate"><span class="pre">l1_norm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.linear_search"><code class="docutils literal notranslate"><span class="pre">linear_search()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.normalize_prevalence"><code class="docutils literal notranslate"><span class="pre">normalize_prevalence()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.num_prevalence_combinations"><code class="docutils literal notranslate"><span class="pre">num_prevalence_combinations()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.optim_minimize"><code class="docutils literal notranslate"><span class="pre">optim_minimize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.prevalence_from_labels"><code class="docutils literal notranslate"><span class="pre">prevalence_from_labels()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.prevalence_from_probabilities"><code class="docutils literal notranslate"><span class="pre">prevalence_from_probabilities()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.prevalence_linspace"><code class="docutils literal notranslate"><span class="pre">prevalence_linspace()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.projection_simplex_sort"><code class="docutils literal notranslate"><span class="pre">projection_simplex_sort()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.softmax"><code class="docutils literal notranslate"><span class="pre">softmax()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.solve_adjustment"><code class="docutils literal notranslate"><span class="pre">solve_adjustment()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.solve_adjustment_binary"><code class="docutils literal notranslate"><span class="pre">solve_adjustment_binary()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.strprev"><code class="docutils literal notranslate"><span class="pre">strprev()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.ternary_search"><code class="docutils literal notranslate"><span class="pre">ternary_search()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.uniform_prevalence"><code class="docutils literal notranslate"><span class="pre">uniform_prevalence()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.uniform_prevalence_sampling"><code class="docutils literal notranslate"><span class="pre">uniform_prevalence_sampling()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.functional.uniform_simplex_sampling"><code class="docutils literal notranslate"><span class="pre">uniform_simplex_sampling()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quapy.model_selection">quapy.model_selection module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quapy.model_selection.ConfigStatus"><code class="docutils literal notranslate"><span class="pre">ConfigStatus</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.ConfigStatus.failed"><code class="docutils literal notranslate"><span class="pre">ConfigStatus.failed()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.ConfigStatus.success"><code class="docutils literal notranslate"><span class="pre">ConfigStatus.success()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.model_selection.GridSearchQ"><code class="docutils literal notranslate"><span class="pre">GridSearchQ</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.GridSearchQ.best_model"><code class="docutils literal notranslate"><span class="pre">GridSearchQ.best_model()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.GridSearchQ.fit"><code class="docutils literal notranslate"><span class="pre">GridSearchQ.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.GridSearchQ.get_params"><code class="docutils literal notranslate"><span class="pre">GridSearchQ.get_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.GridSearchQ.quantify"><code class="docutils literal notranslate"><span class="pre">GridSearchQ.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.GridSearchQ.set_fit_request"><code class="docutils literal notranslate"><span class="pre">GridSearchQ.set_fit_request()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.GridSearchQ.set_params"><code class="docutils literal notranslate"><span class="pre">GridSearchQ.set_params()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.model_selection.Status"><code class="docutils literal notranslate"><span class="pre">Status</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.Status.ERROR"><code class="docutils literal notranslate"><span class="pre">Status.ERROR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.Status.INVALID"><code class="docutils literal notranslate"><span class="pre">Status.INVALID</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.Status.SUCCESS"><code class="docutils literal notranslate"><span class="pre">Status.SUCCESS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.model_selection.Status.TIMEOUT"><code class="docutils literal notranslate"><span class="pre">Status.TIMEOUT</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.model_selection.cross_val_predict"><code class="docutils literal notranslate"><span class="pre">cross_val_predict()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.model_selection.expand_grid"><code class="docutils literal notranslate"><span class="pre">expand_grid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.model_selection.group_params"><code class="docutils literal notranslate"><span class="pre">group_params()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quapy.plot">quapy.plot module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quapy.plot.binary_bias_bins"><code class="docutils literal notranslate"><span class="pre">binary_bias_bins()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.plot.binary_bias_global"><code class="docutils literal notranslate"><span class="pre">binary_bias_global()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.plot.binary_diagonal"><code class="docutils literal notranslate"><span class="pre">binary_diagonal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.plot.brokenbar_supremacy_by_drift"><code class="docutils literal notranslate"><span class="pre">brokenbar_supremacy_by_drift()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.plot.error_by_drift"><code class="docutils literal notranslate"><span class="pre">error_by_drift()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quapy.protocol">quapy.protocol module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quapy.protocol.APP"><code class="docutils literal notranslate"><span class="pre">APP</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.APP.prevalence_grid"><code class="docutils literal notranslate"><span class="pre">APP.prevalence_grid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.APP.sample"><code class="docutils literal notranslate"><span class="pre">APP.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.APP.samples_parameters"><code class="docutils literal notranslate"><span class="pre">APP.samples_parameters()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.APP.total"><code class="docutils literal notranslate"><span class="pre">APP.total()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.protocol.AbstractProtocol"><code class="docutils literal notranslate"><span class="pre">AbstractProtocol</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.AbstractProtocol.total"><code class="docutils literal notranslate"><span class="pre">AbstractProtocol.total()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.protocol.AbstractStochasticSeededProtocol"><code class="docutils literal notranslate"><span class="pre">AbstractStochasticSeededProtocol</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.AbstractStochasticSeededProtocol.collator"><code class="docutils literal notranslate"><span class="pre">AbstractStochasticSeededProtocol.collator()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.AbstractStochasticSeededProtocol.random_state"><code class="docutils literal notranslate"><span class="pre">AbstractStochasticSeededProtocol.random_state</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.AbstractStochasticSeededProtocol.sample"><code class="docutils literal notranslate"><span class="pre">AbstractStochasticSeededProtocol.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.AbstractStochasticSeededProtocol.samples_parameters"><code class="docutils literal notranslate"><span class="pre">AbstractStochasticSeededProtocol.samples_parameters()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.protocol.ArtificialPrevalenceProtocol"><code class="docutils literal notranslate"><span class="pre">ArtificialPrevalenceProtocol</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.protocol.DomainMixer"><code class="docutils literal notranslate"><span class="pre">DomainMixer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.DomainMixer.sample"><code class="docutils literal notranslate"><span class="pre">DomainMixer.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.DomainMixer.samples_parameters"><code class="docutils literal notranslate"><span class="pre">DomainMixer.samples_parameters()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.DomainMixer.total"><code class="docutils literal notranslate"><span class="pre">DomainMixer.total()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.protocol.IterateProtocol"><code class="docutils literal notranslate"><span class="pre">IterateProtocol</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.IterateProtocol.total"><code class="docutils literal notranslate"><span class="pre">IterateProtocol.total()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.protocol.NPP"><code class="docutils literal notranslate"><span class="pre">NPP</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.NPP.sample"><code class="docutils literal notranslate"><span class="pre">NPP.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.NPP.samples_parameters"><code class="docutils literal notranslate"><span class="pre">NPP.samples_parameters()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.NPP.total"><code class="docutils literal notranslate"><span class="pre">NPP.total()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.protocol.NaturalPrevalenceProtocol"><code class="docutils literal notranslate"><span class="pre">NaturalPrevalenceProtocol</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.protocol.OnLabelledCollectionProtocol"><code class="docutils literal notranslate"><span class="pre">OnLabelledCollectionProtocol</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.OnLabelledCollectionProtocol.RETURN_TYPES"><code class="docutils literal notranslate"><span class="pre">OnLabelledCollectionProtocol.RETURN_TYPES</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.OnLabelledCollectionProtocol.get_collator"><code class="docutils literal notranslate"><span class="pre">OnLabelledCollectionProtocol.get_collator()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.OnLabelledCollectionProtocol.get_labelled_collection"><code class="docutils literal notranslate"><span class="pre">OnLabelledCollectionProtocol.get_labelled_collection()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.OnLabelledCollectionProtocol.on_preclassified_instances"><code class="docutils literal notranslate"><span class="pre">OnLabelledCollectionProtocol.on_preclassified_instances()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.protocol.UPP"><code class="docutils literal notranslate"><span class="pre">UPP</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.UPP.sample"><code class="docutils literal notranslate"><span class="pre">UPP.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.UPP.samples_parameters"><code class="docutils literal notranslate"><span class="pre">UPP.samples_parameters()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quapy.protocol.UPP.total"><code class="docutils literal notranslate"><span class="pre">UPP.total()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.protocol.UniformPrevalenceProtocol"><code class="docutils literal notranslate"><span class="pre">UniformPrevalenceProtocol</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quapy.util">quapy.util module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.EarlyStop"><code class="docutils literal notranslate"><span class="pre">EarlyStop</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.create_if_not_exist"><code class="docutils literal notranslate"><span class="pre">create_if_not_exist()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.create_parent_dir"><code class="docutils literal notranslate"><span class="pre">create_parent_dir()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.download_file"><code class="docutils literal notranslate"><span class="pre">download_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.download_file_if_not_exists"><code class="docutils literal notranslate"><span class="pre">download_file_if_not_exists()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.get_quapy_home"><code class="docutils literal notranslate"><span class="pre">get_quapy_home()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.load_report"><code class="docutils literal notranslate"><span class="pre">load_report()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.map_parallel"><code class="docutils literal notranslate"><span class="pre">map_parallel()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.parallel"><code class="docutils literal notranslate"><span class="pre">parallel()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.parallel_unpack"><code class="docutils literal notranslate"><span class="pre">parallel_unpack()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.pickled_resource"><code class="docutils literal notranslate"><span class="pre">pickled_resource()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.save_text_file"><code class="docutils literal notranslate"><span class="pre">save_text_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.temp_seed"><code class="docutils literal notranslate"><span class="pre">temp_seed()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quapy.util.timeout"><code class="docutils literal notranslate"><span class="pre">timeout()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quapy">Module contents</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">QuaPy: A Python-based open-source framework for quantification</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">quapy package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/quapy.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quapy-package">
<h1>quapy package<a class="headerlink" href="#quapy-package" title="Link to this heading"></a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="quapy.classification.html">quapy.classification package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="quapy.classification.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="quapy.classification.html#module-quapy.classification.calibration">quapy.classification.calibration module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.BCTSCalibration"><code class="docutils literal notranslate"><span class="pre">BCTSCalibration</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.NBVSCalibration"><code class="docutils literal notranslate"><span class="pre">NBVSCalibration</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.RecalibratedProbabilisticClassifier"><code class="docutils literal notranslate"><span class="pre">RecalibratedProbabilisticClassifier</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.RecalibratedProbabilisticClassifierBase"><code class="docutils literal notranslate"><span class="pre">RecalibratedProbabilisticClassifierBase</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.RecalibratedProbabilisticClassifierBase.classes_"><code class="docutils literal notranslate"><span class="pre">RecalibratedProbabilisticClassifierBase.classes_</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.RecalibratedProbabilisticClassifierBase.fit"><code class="docutils literal notranslate"><span class="pre">RecalibratedProbabilisticClassifierBase.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.RecalibratedProbabilisticClassifierBase.fit_cv"><code class="docutils literal notranslate"><span class="pre">RecalibratedProbabilisticClassifierBase.fit_cv()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.RecalibratedProbabilisticClassifierBase.fit_tr_val"><code class="docutils literal notranslate"><span class="pre">RecalibratedProbabilisticClassifierBase.fit_tr_val()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.RecalibratedProbabilisticClassifierBase.predict"><code class="docutils literal notranslate"><span class="pre">RecalibratedProbabilisticClassifierBase.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.RecalibratedProbabilisticClassifierBase.predict_proba"><code class="docutils literal notranslate"><span class="pre">RecalibratedProbabilisticClassifierBase.predict_proba()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.TSCalibration"><code class="docutils literal notranslate"><span class="pre">TSCalibration</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.calibration.VSCalibration"><code class="docutils literal notranslate"><span class="pre">VSCalibration</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.classification.html#module-quapy.classification.methods">quapy.classification.methods module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.methods.LowRankLogisticRegression"><code class="docutils literal notranslate"><span class="pre">LowRankLogisticRegression</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.methods.LowRankLogisticRegression.fit"><code class="docutils literal notranslate"><span class="pre">LowRankLogisticRegression.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.methods.LowRankLogisticRegression.get_params"><code class="docutils literal notranslate"><span class="pre">LowRankLogisticRegression.get_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.methods.LowRankLogisticRegression.predict"><code class="docutils literal notranslate"><span class="pre">LowRankLogisticRegression.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.methods.LowRankLogisticRegression.predict_proba"><code class="docutils literal notranslate"><span class="pre">LowRankLogisticRegression.predict_proba()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.methods.LowRankLogisticRegression.set_params"><code class="docutils literal notranslate"><span class="pre">LowRankLogisticRegression.set_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.methods.LowRankLogisticRegression.transform"><code class="docutils literal notranslate"><span class="pre">LowRankLogisticRegression.transform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.classification.html#module-quapy.classification.neural">quapy.classification.neural module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.CNNnet"><code class="docutils literal notranslate"><span class="pre">CNNnet</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.CNNnet.document_embedding"><code class="docutils literal notranslate"><span class="pre">CNNnet.document_embedding()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.CNNnet.get_params"><code class="docutils literal notranslate"><span class="pre">CNNnet.get_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.CNNnet.vocabulary_size"><code class="docutils literal notranslate"><span class="pre">CNNnet.vocabulary_size</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.LSTMnet"><code class="docutils literal notranslate"><span class="pre">LSTMnet</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.LSTMnet.document_embedding"><code class="docutils literal notranslate"><span class="pre">LSTMnet.document_embedding()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.LSTMnet.get_params"><code class="docutils literal notranslate"><span class="pre">LSTMnet.get_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.LSTMnet.vocabulary_size"><code class="docutils literal notranslate"><span class="pre">LSTMnet.vocabulary_size</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.NeuralClassifierTrainer"><code class="docutils literal notranslate"><span class="pre">NeuralClassifierTrainer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.NeuralClassifierTrainer.device"><code class="docutils literal notranslate"><span class="pre">NeuralClassifierTrainer.device</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.NeuralClassifierTrainer.fit"><code class="docutils literal notranslate"><span class="pre">NeuralClassifierTrainer.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.NeuralClassifierTrainer.get_params"><code class="docutils literal notranslate"><span class="pre">NeuralClassifierTrainer.get_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.NeuralClassifierTrainer.predict"><code class="docutils literal notranslate"><span class="pre">NeuralClassifierTrainer.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.NeuralClassifierTrainer.predict_proba"><code class="docutils literal notranslate"><span class="pre">NeuralClassifierTrainer.predict_proba()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.NeuralClassifierTrainer.reset_net_params"><code class="docutils literal notranslate"><span class="pre">NeuralClassifierTrainer.reset_net_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.NeuralClassifierTrainer.set_params"><code class="docutils literal notranslate"><span class="pre">NeuralClassifierTrainer.set_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.NeuralClassifierTrainer.transform"><code class="docutils literal notranslate"><span class="pre">NeuralClassifierTrainer.transform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.TextClassifierNet"><code class="docutils literal notranslate"><span class="pre">TextClassifierNet</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.TextClassifierNet.dimensions"><code class="docutils literal notranslate"><span class="pre">TextClassifierNet.dimensions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.TextClassifierNet.document_embedding"><code class="docutils literal notranslate"><span class="pre">TextClassifierNet.document_embedding()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.TextClassifierNet.forward"><code class="docutils literal notranslate"><span class="pre">TextClassifierNet.forward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.TextClassifierNet.get_params"><code class="docutils literal notranslate"><span class="pre">TextClassifierNet.get_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.TextClassifierNet.predict_proba"><code class="docutils literal notranslate"><span class="pre">TextClassifierNet.predict_proba()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.TextClassifierNet.vocabulary_size"><code class="docutils literal notranslate"><span class="pre">TextClassifierNet.vocabulary_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.TextClassifierNet.xavier_uniform"><code class="docutils literal notranslate"><span class="pre">TextClassifierNet.xavier_uniform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.TorchDataset"><code class="docutils literal notranslate"><span class="pre">TorchDataset</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.neural.TorchDataset.asDataloader"><code class="docutils literal notranslate"><span class="pre">TorchDataset.asDataloader()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.classification.html#module-quapy.classification.svmperf">quapy.classification.svmperf module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.classification.html#quapy.classification.svmperf.SVMperf"><code class="docutils literal notranslate"><span class="pre">SVMperf</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.svmperf.SVMperf.decision_function"><code class="docutils literal notranslate"><span class="pre">SVMperf.decision_function()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.svmperf.SVMperf.fit"><code class="docutils literal notranslate"><span class="pre">SVMperf.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.svmperf.SVMperf.predict"><code class="docutils literal notranslate"><span class="pre">SVMperf.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.svmperf.SVMperf.set_score_request"><code class="docutils literal notranslate"><span class="pre">SVMperf.set_score_request()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.classification.html#quapy.classification.svmperf.SVMperf.valid_losses"><code class="docutils literal notranslate"><span class="pre">SVMperf.valid_losses</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.classification.html#module-quapy.classification">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="quapy.data.html">quapy.data package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="quapy.data.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="quapy.data.html#module-quapy.data.base">quapy.data.base module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.base.Dataset"><code class="docutils literal notranslate"><span class="pre">Dataset</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.Dataset.SplitStratified"><code class="docutils literal notranslate"><span class="pre">Dataset.SplitStratified()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.Dataset.binary"><code class="docutils literal notranslate"><span class="pre">Dataset.binary</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.Dataset.classes_"><code class="docutils literal notranslate"><span class="pre">Dataset.classes_</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.Dataset.kFCV"><code class="docutils literal notranslate"><span class="pre">Dataset.kFCV()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.Dataset.load"><code class="docutils literal notranslate"><span class="pre">Dataset.load()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.Dataset.n_classes"><code class="docutils literal notranslate"><span class="pre">Dataset.n_classes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.Dataset.reduce"><code class="docutils literal notranslate"><span class="pre">Dataset.reduce()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.Dataset.stats"><code class="docutils literal notranslate"><span class="pre">Dataset.stats()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.Dataset.train_test"><code class="docutils literal notranslate"><span class="pre">Dataset.train_test</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.Dataset.vocabulary_size"><code class="docutils literal notranslate"><span class="pre">Dataset.vocabulary_size</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection"><code class="docutils literal notranslate"><span class="pre">LabelledCollection</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.X"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.X</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.Xp"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.Xp</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.Xy"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.Xy</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.binary"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.binary</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.counts"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.counts()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.join"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.join()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.kFCV"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.kFCV()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.load"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.load()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.n_classes"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.n_classes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.p"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.p</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.prevalence"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.prevalence()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.sampling"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.sampling()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.sampling_from_index"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.sampling_from_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.sampling_index"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.sampling_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.split_random"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.split_random()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.split_stratified"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.split_stratified()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.stats"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.stats()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.uniform_sampling"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.uniform_sampling()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.uniform_sampling_index"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.uniform_sampling_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection.y"><code class="docutils literal notranslate"><span class="pre">LabelledCollection.y</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.data.html#module-quapy.data.datasets">quapy.data.datasets module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.datasets.fetch_IFCB"><code class="docutils literal notranslate"><span class="pre">fetch_IFCB()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.datasets.fetch_UCIBinaryDataset"><code class="docutils literal notranslate"><span class="pre">fetch_UCIBinaryDataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.datasets.fetch_UCIBinaryLabelledCollection"><code class="docutils literal notranslate"><span class="pre">fetch_UCIBinaryLabelledCollection()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.datasets.fetch_UCIMulticlassDataset"><code class="docutils literal notranslate"><span class="pre">fetch_UCIMulticlassDataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.datasets.fetch_UCIMulticlassLabelledCollection"><code class="docutils literal notranslate"><span class="pre">fetch_UCIMulticlassLabelledCollection()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.datasets.fetch_lequa2022"><code class="docutils literal notranslate"><span class="pre">fetch_lequa2022()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.datasets.fetch_lequa2024"><code class="docutils literal notranslate"><span class="pre">fetch_lequa2024()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.datasets.fetch_reviews"><code class="docutils literal notranslate"><span class="pre">fetch_reviews()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.datasets.fetch_twitter"><code class="docutils literal notranslate"><span class="pre">fetch_twitter()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.data.html#module-quapy.data.preprocessing">quapy.data.preprocessing module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.preprocessing.IndexTransformer"><code class="docutils literal notranslate"><span class="pre">IndexTransformer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.preprocessing.IndexTransformer.add_word"><code class="docutils literal notranslate"><span class="pre">IndexTransformer.add_word()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.preprocessing.IndexTransformer.fit"><code class="docutils literal notranslate"><span class="pre">IndexTransformer.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.preprocessing.IndexTransformer.fit_transform"><code class="docutils literal notranslate"><span class="pre">IndexTransformer.fit_transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.preprocessing.IndexTransformer.transform"><code class="docutils literal notranslate"><span class="pre">IndexTransformer.transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.data.html#quapy.data.preprocessing.IndexTransformer.vocabulary_size"><code class="docutils literal notranslate"><span class="pre">IndexTransformer.vocabulary_size()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.preprocessing.index"><code class="docutils literal notranslate"><span class="pre">index()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.preprocessing.reduce_columns"><code class="docutils literal notranslate"><span class="pre">reduce_columns()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.preprocessing.standardize"><code class="docutils literal notranslate"><span class="pre">standardize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.preprocessing.text2tfidf"><code class="docutils literal notranslate"><span class="pre">text2tfidf()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.data.html#module-quapy.data.reader">quapy.data.reader module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.reader.binarize"><code class="docutils literal notranslate"><span class="pre">binarize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.reader.from_csv"><code class="docutils literal notranslate"><span class="pre">from_csv()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.reader.from_sparse"><code class="docutils literal notranslate"><span class="pre">from_sparse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.reader.from_text"><code class="docutils literal notranslate"><span class="pre">from_text()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.data.html#quapy.data.reader.reindex_labels"><code class="docutils literal notranslate"><span class="pre">reindex_labels()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.data.html#module-quapy.data">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="quapy.method.html">quapy.method package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="quapy.method.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="quapy.method.html#module-quapy.method.aggregative">quapy.method.aggregative module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ACC"><code class="docutils literal notranslate"><span class="pre">ACC</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ACC.METHODS"><code class="docutils literal notranslate"><span class="pre">ACC.METHODS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ACC.NORMALIZATIONS"><code class="docutils literal notranslate"><span class="pre">ACC.NORMALIZATIONS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ACC.SOLVERS"><code class="docutils literal notranslate"><span class="pre">ACC.SOLVERS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ACC.aggregate"><code class="docutils literal notranslate"><span class="pre">ACC.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ACC.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">ACC.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ACC.getPteCondEstim"><code class="docutils literal notranslate"><span class="pre">ACC.getPteCondEstim()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ACC.newInvariantRatioEstimation"><code class="docutils literal notranslate"><span class="pre">ACC.newInvariantRatioEstimation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ACC.set_fit_request"><code class="docutils literal notranslate"><span class="pre">ACC.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AdjustedClassifyAndCount"><code class="docutils literal notranslate"><span class="pre">AdjustedClassifyAndCount</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeCrispQuantifier"><code class="docutils literal notranslate"><span class="pre">AggregativeCrispQuantifier</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeCrispQuantifier.set_fit_request"><code class="docutils literal notranslate"><span class="pre">AggregativeCrispQuantifier.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeMedianEstimator"><code class="docutils literal notranslate"><span class="pre">AggregativeMedianEstimator</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeMedianEstimator.fit"><code class="docutils literal notranslate"><span class="pre">AggregativeMedianEstimator.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeMedianEstimator.get_params"><code class="docutils literal notranslate"><span class="pre">AggregativeMedianEstimator.get_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeMedianEstimator.quantify"><code class="docutils literal notranslate"><span class="pre">AggregativeMedianEstimator.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeMedianEstimator.set_fit_request"><code class="docutils literal notranslate"><span class="pre">AggregativeMedianEstimator.set_fit_request()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeMedianEstimator.set_params"><code class="docutils literal notranslate"><span class="pre">AggregativeMedianEstimator.set_params()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier.aggregate"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier.classes_"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier.classes_</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier.classifier"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier.classifier</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier.classifier_fit_predict"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier.classifier_fit_predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier.classify"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier.classify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier.fit"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier.quantify"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier.set_fit_request"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier.set_fit_request()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier.val_split"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier.val_split</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeQuantifier.val_split_"><code class="docutils literal notranslate"><span class="pre">AggregativeQuantifier.val_split_</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeSoftQuantifier"><code class="docutils literal notranslate"><span class="pre">AggregativeSoftQuantifier</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.AggregativeSoftQuantifier.set_fit_request"><code class="docutils literal notranslate"><span class="pre">AggregativeSoftQuantifier.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BayesianCC"><code class="docutils literal notranslate"><span class="pre">BayesianCC</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BayesianCC.aggregate"><code class="docutils literal notranslate"><span class="pre">BayesianCC.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BayesianCC.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">BayesianCC.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BayesianCC.get_conditional_probability_samples"><code class="docutils literal notranslate"><span class="pre">BayesianCC.get_conditional_probability_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BayesianCC.get_prevalence_samples"><code class="docutils literal notranslate"><span class="pre">BayesianCC.get_prevalence_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BayesianCC.sample_from_posterior"><code class="docutils literal notranslate"><span class="pre">BayesianCC.sample_from_posterior()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BayesianCC.set_fit_request"><code class="docutils literal notranslate"><span class="pre">BayesianCC.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BinaryAggregativeQuantifier"><code class="docutils literal notranslate"><span class="pre">BinaryAggregativeQuantifier</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BinaryAggregativeQuantifier.fit"><code class="docutils literal notranslate"><span class="pre">BinaryAggregativeQuantifier.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BinaryAggregativeQuantifier.neg_label"><code class="docutils literal notranslate"><span class="pre">BinaryAggregativeQuantifier.neg_label</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BinaryAggregativeQuantifier.pos_label"><code class="docutils literal notranslate"><span class="pre">BinaryAggregativeQuantifier.pos_label</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.BinaryAggregativeQuantifier.set_fit_request"><code class="docutils literal notranslate"><span class="pre">BinaryAggregativeQuantifier.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.CC"><code class="docutils literal notranslate"><span class="pre">CC</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.CC.aggregate"><code class="docutils literal notranslate"><span class="pre">CC.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.CC.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">CC.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.CC.set_fit_request"><code class="docutils literal notranslate"><span class="pre">CC.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ClassifyAndCount"><code class="docutils literal notranslate"><span class="pre">ClassifyAndCount</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.DMy"><code class="docutils literal notranslate"><span class="pre">DMy</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.DMy.aggregate"><code class="docutils literal notranslate"><span class="pre">DMy.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.DMy.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">DMy.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.DMy.set_fit_request"><code class="docutils literal notranslate"><span class="pre">DMy.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.DistributionMatchingY"><code class="docutils literal notranslate"><span class="pre">DistributionMatchingY</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.DyS"><code class="docutils literal notranslate"><span class="pre">DyS</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.DyS.aggregate"><code class="docutils literal notranslate"><span class="pre">DyS.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.DyS.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">DyS.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.DyS.set_fit_request"><code class="docutils literal notranslate"><span class="pre">DyS.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.EMQ"><code class="docutils literal notranslate"><span class="pre">EMQ</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.EMQ.EM"><code class="docutils literal notranslate"><span class="pre">EMQ.EM()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.EMQ.EMQ_BCTS"><code class="docutils literal notranslate"><span class="pre">EMQ.EMQ_BCTS()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.EMQ.EPSILON"><code class="docutils literal notranslate"><span class="pre">EMQ.EPSILON</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.EMQ.MAX_ITER"><code class="docutils literal notranslate"><span class="pre">EMQ.MAX_ITER</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.EMQ.aggregate"><code class="docutils literal notranslate"><span class="pre">EMQ.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.EMQ.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">EMQ.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.EMQ.classify"><code class="docutils literal notranslate"><span class="pre">EMQ.classify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.EMQ.predict_proba"><code class="docutils literal notranslate"><span class="pre">EMQ.predict_proba()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.EMQ.set_fit_request"><code class="docutils literal notranslate"><span class="pre">EMQ.set_fit_request()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.EMQ.set_predict_proba_request"><code class="docutils literal notranslate"><span class="pre">EMQ.set_predict_proba_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ExpectationMaximizationQuantifier"><code class="docutils literal notranslate"><span class="pre">ExpectationMaximizationQuantifier</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.HDy"><code class="docutils literal notranslate"><span class="pre">HDy</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.HDy.aggregate"><code class="docutils literal notranslate"><span class="pre">HDy.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.HDy.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">HDy.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.HDy.set_fit_request"><code class="docutils literal notranslate"><span class="pre">HDy.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.HellingerDistanceY"><code class="docutils literal notranslate"><span class="pre">HellingerDistanceY</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.OneVsAllAggregative"><code class="docutils literal notranslate"><span class="pre">OneVsAllAggregative</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.OneVsAllAggregative.aggregate"><code class="docutils literal notranslate"><span class="pre">OneVsAllAggregative.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.OneVsAllAggregative.classify"><code class="docutils literal notranslate"><span class="pre">OneVsAllAggregative.classify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.OneVsAllAggregative.set_fit_request"><code class="docutils literal notranslate"><span class="pre">OneVsAllAggregative.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.PACC"><code class="docutils literal notranslate"><span class="pre">PACC</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.PACC.aggregate"><code class="docutils literal notranslate"><span class="pre">PACC.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.PACC.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">PACC.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.PACC.getPteCondEstim"><code class="docutils literal notranslate"><span class="pre">PACC.getPteCondEstim()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.PACC.set_fit_request"><code class="docutils literal notranslate"><span class="pre">PACC.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.PCC"><code class="docutils literal notranslate"><span class="pre">PCC</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.PCC.aggregate"><code class="docutils literal notranslate"><span class="pre">PCC.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.PCC.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">PCC.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.PCC.set_fit_request"><code class="docutils literal notranslate"><span class="pre">PCC.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ProbabilisticAdjustedClassifyAndCount"><code class="docutils literal notranslate"><span class="pre">ProbabilisticAdjustedClassifyAndCount</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.ProbabilisticClassifyAndCount"><code class="docutils literal notranslate"><span class="pre">ProbabilisticClassifyAndCount</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.SLD"><code class="docutils literal notranslate"><span class="pre">SLD</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.SMM"><code class="docutils literal notranslate"><span class="pre">SMM</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.SMM.aggregate"><code class="docutils literal notranslate"><span class="pre">SMM.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.SMM.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">SMM.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.SMM.set_fit_request"><code class="docutils literal notranslate"><span class="pre">SMM.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.newELM"><code class="docutils literal notranslate"><span class="pre">newELM()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.newSVMAE"><code class="docutils literal notranslate"><span class="pre">newSVMAE()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.newSVMKLD"><code class="docutils literal notranslate"><span class="pre">newSVMKLD()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.newSVMQ"><code class="docutils literal notranslate"><span class="pre">newSVMQ()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.aggregative.newSVMRAE"><code class="docutils literal notranslate"><span class="pre">newSVMRAE()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEBase"><code class="docutils literal notranslate"><span class="pre">KDEBase</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEBase.BANDWIDTH_METHOD"><code class="docutils literal notranslate"><span class="pre">KDEBase.BANDWIDTH_METHOD</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEBase.get_kde_function"><code class="docutils literal notranslate"><span class="pre">KDEBase.get_kde_function()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEBase.get_mixture_components"><code class="docutils literal notranslate"><span class="pre">KDEBase.get_mixture_components()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEBase.pdf"><code class="docutils literal notranslate"><span class="pre">KDEBase.pdf()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyCS"><code class="docutils literal notranslate"><span class="pre">KDEyCS</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyCS.aggregate"><code class="docutils literal notranslate"><span class="pre">KDEyCS.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyCS.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">KDEyCS.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyCS.gram_matrix_mix_sum"><code class="docutils literal notranslate"><span class="pre">KDEyCS.gram_matrix_mix_sum()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyCS.set_fit_request"><code class="docutils literal notranslate"><span class="pre">KDEyCS.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyHD"><code class="docutils literal notranslate"><span class="pre">KDEyHD</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyHD.aggregate"><code class="docutils literal notranslate"><span class="pre">KDEyHD.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyHD.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">KDEyHD.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyHD.set_fit_request"><code class="docutils literal notranslate"><span class="pre">KDEyHD.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyML"><code class="docutils literal notranslate"><span class="pre">KDEyML</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyML.aggregate"><code class="docutils literal notranslate"><span class="pre">KDEyML.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyML.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">KDEyML.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._kdey.KDEyML.set_fit_request"><code class="docutils literal notranslate"><span class="pre">KDEyML.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetModule"><code class="docutils literal notranslate"><span class="pre">QuaNetModule</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetModule.device"><code class="docutils literal notranslate"><span class="pre">QuaNetModule.device</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetModule.forward"><code class="docutils literal notranslate"><span class="pre">QuaNetModule.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetTrainer"><code class="docutils literal notranslate"><span class="pre">QuaNetTrainer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetTrainer.classes_"><code class="docutils literal notranslate"><span class="pre">QuaNetTrainer.classes_</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetTrainer.clean_checkpoint"><code class="docutils literal notranslate"><span class="pre">QuaNetTrainer.clean_checkpoint()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetTrainer.clean_checkpoint_dir"><code class="docutils literal notranslate"><span class="pre">QuaNetTrainer.clean_checkpoint_dir()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetTrainer.fit"><code class="docutils literal notranslate"><span class="pre">QuaNetTrainer.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetTrainer.get_params"><code class="docutils literal notranslate"><span class="pre">QuaNetTrainer.get_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetTrainer.quantify"><code class="docutils literal notranslate"><span class="pre">QuaNetTrainer.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetTrainer.set_fit_request"><code class="docutils literal notranslate"><span class="pre">QuaNetTrainer.set_fit_request()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._neural.QuaNetTrainer.set_params"><code class="docutils literal notranslate"><span class="pre">QuaNetTrainer.set_params()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._neural.mae_loss"><code class="docutils literal notranslate"><span class="pre">mae_loss()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.MAX"><code class="docutils literal notranslate"><span class="pre">MAX</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.MAX.condition"><code class="docutils literal notranslate"><span class="pre">MAX.condition()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.MAX.set_fit_request"><code class="docutils literal notranslate"><span class="pre">MAX.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.MS"><code class="docutils literal notranslate"><span class="pre">MS</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.MS.aggregate"><code class="docutils literal notranslate"><span class="pre">MS.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.MS.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">MS.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.MS.condition"><code class="docutils literal notranslate"><span class="pre">MS.condition()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.MS.set_fit_request"><code class="docutils literal notranslate"><span class="pre">MS.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.MS2"><code class="docutils literal notranslate"><span class="pre">MS2</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.MS2.discard"><code class="docutils literal notranslate"><span class="pre">MS2.discard()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.MS2.set_fit_request"><code class="docutils literal notranslate"><span class="pre">MS2.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.T50"><code class="docutils literal notranslate"><span class="pre">T50</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.T50.condition"><code class="docutils literal notranslate"><span class="pre">T50.condition()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.T50.set_fit_request"><code class="docutils literal notranslate"><span class="pre">T50.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.ThresholdOptimization"><code class="docutils literal notranslate"><span class="pre">ThresholdOptimization</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.ThresholdOptimization.aggregate"><code class="docutils literal notranslate"><span class="pre">ThresholdOptimization.aggregate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.ThresholdOptimization.aggregate_with_threshold"><code class="docutils literal notranslate"><span class="pre">ThresholdOptimization.aggregate_with_threshold()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.ThresholdOptimization.aggregation_fit"><code class="docutils literal notranslate"><span class="pre">ThresholdOptimization.aggregation_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.ThresholdOptimization.condition"><code class="docutils literal notranslate"><span class="pre">ThresholdOptimization.condition()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.ThresholdOptimization.discard"><code class="docutils literal notranslate"><span class="pre">ThresholdOptimization.discard()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.ThresholdOptimization.set_fit_request"><code class="docutils literal notranslate"><span class="pre">ThresholdOptimization.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.X"><code class="docutils literal notranslate"><span class="pre">X</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.X.condition"><code class="docutils literal notranslate"><span class="pre">X.condition()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method._threshold_optim.X.set_fit_request"><code class="docutils literal notranslate"><span class="pre">X.set_fit_request()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.method.html#module-quapy.method.base">quapy.method.base module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier"><code class="docutils literal notranslate"><span class="pre">BaseQuantifier</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier.fit"><code class="docutils literal notranslate"><span class="pre">BaseQuantifier.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier.quantify"><code class="docutils literal notranslate"><span class="pre">BaseQuantifier.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier.set_fit_request"><code class="docutils literal notranslate"><span class="pre">BaseQuantifier.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.base.BinaryQuantifier"><code class="docutils literal notranslate"><span class="pre">BinaryQuantifier</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.base.BinaryQuantifier.set_fit_request"><code class="docutils literal notranslate"><span class="pre">BinaryQuantifier.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.base.OneVsAll"><code class="docutils literal notranslate"><span class="pre">OneVsAll</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.base.OneVsAllGeneric"><code class="docutils literal notranslate"><span class="pre">OneVsAllGeneric</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.base.OneVsAllGeneric.classes_"><code class="docutils literal notranslate"><span class="pre">OneVsAllGeneric.classes_</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.base.OneVsAllGeneric.fit"><code class="docutils literal notranslate"><span class="pre">OneVsAllGeneric.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.base.OneVsAllGeneric.quantify"><code class="docutils literal notranslate"><span class="pre">OneVsAllGeneric.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.base.OneVsAllGeneric.set_fit_request"><code class="docutils literal notranslate"><span class="pre">OneVsAllGeneric.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.base.newOneVsAll"><code class="docutils literal notranslate"><span class="pre">newOneVsAll()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.method.html#module-quapy.method.meta">quapy.method.meta module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.meta.EACC"><code class="docutils literal notranslate"><span class="pre">EACC()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.meta.ECC"><code class="docutils literal notranslate"><span class="pre">ECC()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.meta.EEMQ"><code class="docutils literal notranslate"><span class="pre">EEMQ()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.meta.EHDy"><code class="docutils literal notranslate"><span class="pre">EHDy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.meta.EPACC"><code class="docutils literal notranslate"><span class="pre">EPACC()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.meta.Ensemble"><code class="docutils literal notranslate"><span class="pre">Ensemble</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.Ensemble.VALID_POLICIES"><code class="docutils literal notranslate"><span class="pre">Ensemble.VALID_POLICIES</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.Ensemble.aggregative"><code class="docutils literal notranslate"><span class="pre">Ensemble.aggregative</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.Ensemble.fit"><code class="docutils literal notranslate"><span class="pre">Ensemble.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.Ensemble.get_params"><code class="docutils literal notranslate"><span class="pre">Ensemble.get_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.Ensemble.probabilistic"><code class="docutils literal notranslate"><span class="pre">Ensemble.probabilistic</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.Ensemble.quantify"><code class="docutils literal notranslate"><span class="pre">Ensemble.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.Ensemble.set_fit_request"><code class="docutils literal notranslate"><span class="pre">Ensemble.set_fit_request()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.Ensemble.set_params"><code class="docutils literal notranslate"><span class="pre">Ensemble.set_params()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator"><code class="docutils literal notranslate"><span class="pre">MedianEstimator</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator.fit"><code class="docutils literal notranslate"><span class="pre">MedianEstimator.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator.get_params"><code class="docutils literal notranslate"><span class="pre">MedianEstimator.get_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator.quantify"><code class="docutils literal notranslate"><span class="pre">MedianEstimator.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator.set_fit_request"><code class="docutils literal notranslate"><span class="pre">MedianEstimator.set_fit_request()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator.set_params"><code class="docutils literal notranslate"><span class="pre">MedianEstimator.set_params()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator2"><code class="docutils literal notranslate"><span class="pre">MedianEstimator2</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator2.fit"><code class="docutils literal notranslate"><span class="pre">MedianEstimator2.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator2.get_params"><code class="docutils literal notranslate"><span class="pre">MedianEstimator2.get_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator2.quantify"><code class="docutils literal notranslate"><span class="pre">MedianEstimator2.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator2.set_fit_request"><code class="docutils literal notranslate"><span class="pre">MedianEstimator2.set_fit_request()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.meta.MedianEstimator2.set_params"><code class="docutils literal notranslate"><span class="pre">MedianEstimator2.set_params()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.meta.ensembleFactory"><code class="docutils literal notranslate"><span class="pre">ensembleFactory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.meta.get_probability_distribution"><code class="docutils literal notranslate"><span class="pre">get_probability_distribution()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.method.html#module-quapy.method.non_aggregative">quapy.method.non_aggregative module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.DMx"><code class="docutils literal notranslate"><span class="pre">DMx</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.DMx.HDx"><code class="docutils literal notranslate"><span class="pre">DMx.HDx()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.DMx.fit"><code class="docutils literal notranslate"><span class="pre">DMx.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.DMx.quantify"><code class="docutils literal notranslate"><span class="pre">DMx.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.DMx.set_fit_request"><code class="docutils literal notranslate"><span class="pre">DMx.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.DistributionMatchingX"><code class="docutils literal notranslate"><span class="pre">DistributionMatchingX</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.MaximumLikelihoodPrevalenceEstimation"><code class="docutils literal notranslate"><span class="pre">MaximumLikelihoodPrevalenceEstimation</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.MaximumLikelihoodPrevalenceEstimation.fit"><code class="docutils literal notranslate"><span class="pre">MaximumLikelihoodPrevalenceEstimation.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.MaximumLikelihoodPrevalenceEstimation.quantify"><code class="docutils literal notranslate"><span class="pre">MaximumLikelihoodPrevalenceEstimation.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.MaximumLikelihoodPrevalenceEstimation.set_fit_request"><code class="docutils literal notranslate"><span class="pre">MaximumLikelihoodPrevalenceEstimation.set_fit_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.ReadMe"><code class="docutils literal notranslate"><span class="pre">ReadMe</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.ReadMe.fit"><code class="docutils literal notranslate"><span class="pre">ReadMe.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.ReadMe.quantify"><code class="docutils literal notranslate"><span class="pre">ReadMe.quantify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.ReadMe.set_fit_request"><code class="docutils literal notranslate"><span class="pre">ReadMe.set_fit_request()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.non_aggregative.ReadMe.std_constrained_linear_ls"><code class="docutils literal notranslate"><span class="pre">ReadMe.std_constrained_linear_ls()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.method.html#module-quapy.method.composable">quapy.method.composable module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.BlobelLoss"><code class="docutils literal notranslate"><span class="pre">BlobelLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.CVClassifier"><code class="docutils literal notranslate"><span class="pre">CVClassifier</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.CVClassifier.fit"><code class="docutils literal notranslate"><span class="pre">CVClassifier.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.CVClassifier.predict"><code class="docutils literal notranslate"><span class="pre">CVClassifier.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.CVClassifier.predict_proba"><code class="docutils literal notranslate"><span class="pre">CVClassifier.predict_proba()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.CVClassifier.set_score_request"><code class="docutils literal notranslate"><span class="pre">CVClassifier.set_score_request()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.ClassTransformer"><code class="docutils literal notranslate"><span class="pre">ClassTransformer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.ClassTransformer.fit_transform"><code class="docutils literal notranslate"><span class="pre">ClassTransformer.fit_transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.ClassTransformer.transform"><code class="docutils literal notranslate"><span class="pre">ClassTransformer.transform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.CombinedLoss"><code class="docutils literal notranslate"><span class="pre">CombinedLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.ComposableQuantifier"><code class="docutils literal notranslate"><span class="pre">ComposableQuantifier()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.DistanceTransformer"><code class="docutils literal notranslate"><span class="pre">DistanceTransformer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.DistanceTransformer.fit_transform"><code class="docutils literal notranslate"><span class="pre">DistanceTransformer.fit_transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.DistanceTransformer.transform"><code class="docutils literal notranslate"><span class="pre">DistanceTransformer.transform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.EnergyKernelTransformer"><code class="docutils literal notranslate"><span class="pre">EnergyKernelTransformer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.EnergyKernelTransformer.fit_transform"><code class="docutils literal notranslate"><span class="pre">EnergyKernelTransformer.fit_transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.EnergyKernelTransformer.transform"><code class="docutils literal notranslate"><span class="pre">EnergyKernelTransformer.transform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.EnergyLoss"><code class="docutils literal notranslate"><span class="pre">EnergyLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.GaussianKernelTransformer"><code class="docutils literal notranslate"><span class="pre">GaussianKernelTransformer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.GaussianKernelTransformer.fit_transform"><code class="docutils literal notranslate"><span class="pre">GaussianKernelTransformer.fit_transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.GaussianKernelTransformer.transform"><code class="docutils literal notranslate"><span class="pre">GaussianKernelTransformer.transform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.GaussianRFFKernelTransformer"><code class="docutils literal notranslate"><span class="pre">GaussianRFFKernelTransformer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.GaussianRFFKernelTransformer.fit_transform"><code class="docutils literal notranslate"><span class="pre">GaussianRFFKernelTransformer.fit_transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.GaussianRFFKernelTransformer.transform"><code class="docutils literal notranslate"><span class="pre">GaussianRFFKernelTransformer.transform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.HellingerSurrogateLoss"><code class="docutils literal notranslate"><span class="pre">HellingerSurrogateLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.HistogramTransformer"><code class="docutils literal notranslate"><span class="pre">HistogramTransformer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.HistogramTransformer.fit_transform"><code class="docutils literal notranslate"><span class="pre">HistogramTransformer.fit_transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.HistogramTransformer.transform"><code class="docutils literal notranslate"><span class="pre">HistogramTransformer.transform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.KernelTransformer"><code class="docutils literal notranslate"><span class="pre">KernelTransformer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.KernelTransformer.fit_transform"><code class="docutils literal notranslate"><span class="pre">KernelTransformer.fit_transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.KernelTransformer.transform"><code class="docutils literal notranslate"><span class="pre">KernelTransformer.transform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.LaplacianKernelTransformer"><code class="docutils literal notranslate"><span class="pre">LaplacianKernelTransformer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="quapy.method.html#quapy.method.composable.LaplacianKernelTransformer.kernel"><code class="docutils literal notranslate"><span class="pre">LaplacianKernelTransformer.kernel</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.LeastSquaresLoss"><code class="docutils literal notranslate"><span class="pre">LeastSquaresLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.TikhonovRegularization"><code class="docutils literal notranslate"><span class="pre">TikhonovRegularization</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="quapy.method.html#quapy.method.composable.TikhonovRegularized"><code class="docutils literal notranslate"><span class="pre">TikhonovRegularized()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quapy.method.html#module-quapy.method">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-quapy.error">
<span id="quapy-error-module"></span><h2>quapy.error module<a class="headerlink" href="#module-quapy.error" title="Link to this heading"></a></h2>
<p>Implementation of error measures used for quantification</p>
<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.absolute_error">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.absolute_error" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes the absolute error between the two prevalence vectors.</dt><dd><p>Absolute error between two prevalence vectors <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\hat{p}\)</span>  is computed as
<span class="math notranslate nohighlight">\(AE(p,\hat{p})=\frac{1}{|\mathcal{Y}|}\sum_{y\in \mathcal{Y}}|\hat{p}(y)-p(y)|\)</span>,
where <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span> are the classes of interest.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> with the predicted prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.acc_error">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">acc_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_pred</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.acc_error" title="Link to this definition"></a></dt>
<dd><p>Computes the error in terms of 1-accuracy. The accuracy is computed as
<span class="math notranslate nohighlight">\(\frac{tp+tn}{tp+fp+fn+tn}\)</span>, with <cite>tp</cite>, <cite>fp</cite>, <cite>fn</cite>, and <cite>tn</cite> standing
for true positives, false positives, false negatives, and true negatives,
respectively</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_true</strong> – array-like of true labels</p></li>
<li><p><strong>y_pred</strong> – array-like of predicted labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>1-accuracy</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.acce">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">acce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_pred</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#acce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.acce" title="Link to this definition"></a></dt>
<dd><p>Computes the error in terms of 1-accuracy. The accuracy is computed as
<span class="math notranslate nohighlight">\(\frac{tp+tn}{tp+fp+fn+tn}\)</span>, with <cite>tp</cite>, <cite>fp</cite>, <cite>fn</cite>, and <cite>tn</cite> standing
for true positives, false positives, false negatives, and true negatives,
respectively</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_true</strong> – array-like of true labels</p></li>
<li><p><strong>y_pred</strong> – array-like of predicted labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>1-accuracy</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.ae">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">ae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#ae"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.ae" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes the absolute error between the two prevalence vectors.</dt><dd><p>Absolute error between two prevalence vectors <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\hat{p}\)</span>  is computed as
<span class="math notranslate nohighlight">\(AE(p,\hat{p})=\frac{1}{|\mathcal{Y}|}\sum_{y\in \mathcal{Y}}|\hat{p}(y)-p(y)|\)</span>,
where <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span> are the classes of interest.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> with the predicted prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.f1_error">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">f1_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_pred</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.f1_error" title="Link to this definition"></a></dt>
<dd><p>F1 error: simply computes the error in terms of macro <span class="math notranslate nohighlight">\(F_1\)</span>, i.e.,
<span class="math notranslate nohighlight">\(1-F_1^M\)</span>, where <span class="math notranslate nohighlight">\(F_1\)</span> is the harmonic mean of precision and recall,
defined as <span class="math notranslate nohighlight">\(\frac{2tp}{2tp+fp+fn}\)</span>, with <cite>tp</cite>, <cite>fp</cite>, and <cite>fn</cite> standing
for true positives, false positives, and false negatives, respectively.
<cite>Macro</cite> averaging means the <span class="math notranslate nohighlight">\(F_1\)</span> is computed for each category independently,
and then averaged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_true</strong> – array-like of true labels</p></li>
<li><p><strong>y_pred</strong> – array-like of predicted labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(1-F_1^M\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.f1e">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">f1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_pred</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#f1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.f1e" title="Link to this definition"></a></dt>
<dd><p>F1 error: simply computes the error in terms of macro <span class="math notranslate nohighlight">\(F_1\)</span>, i.e.,
<span class="math notranslate nohighlight">\(1-F_1^M\)</span>, where <span class="math notranslate nohighlight">\(F_1\)</span> is the harmonic mean of precision and recall,
defined as <span class="math notranslate nohighlight">\(\frac{2tp}{2tp+fp+fn}\)</span>, with <cite>tp</cite>, <cite>fp</cite>, and <cite>fn</cite> standing
for true positives, false positives, and false negatives, respectively.
<cite>Macro</cite> averaging means the <span class="math notranslate nohighlight">\(F_1\)</span> is computed for each category independently,
and then averaged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_true</strong> – array-like of true labels</p></li>
<li><p><strong>y_pred</strong> – array-like of predicted labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(1-F_1^M\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.from_name">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">from_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">err_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#from_name"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.from_name" title="Link to this definition"></a></dt>
<dd><p>Gets an error function from its name. E.g., <cite>from_name(“mae”)</cite>
will return function <a class="reference internal" href="#quapy.error.mae" title="quapy.error.mae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.mae()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>err_name</strong> – string, the error name</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a callable implementing the requested error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.kld">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">kld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#kld"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.kld" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes the Kullback-Leibler divergence between the two prevalence distributions.</dt><dd><p>Kullback-Leibler divergence between two prevalence distributions <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\hat{p}\)</span>
is computed as
<span class="math notranslate nohighlight">\(KLD(p,\hat{p})=D_{KL}(p||\hat{p})=
\sum_{y\in \mathcal{Y}} p(y)\log\frac{p(y)}{\hat{p}(y)}\)</span>,
where <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span> are the classes of interest.
The distributions are smoothed using the <cite>eps</cite> factor (see <a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> with the predicted prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. KLD is not defined in cases in which the distributions contain
zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>, with <span class="math notranslate nohighlight">\(T\)</span> the sample size.
If <cite>eps=None</cite>, the sample size will be taken from the environment variable <cite>SAMPLE_SIZE</cite>
(which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Kullback-Leibler divergence between the two distributions</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.mae">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">mae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#mae"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.mae" title="Link to this definition"></a></dt>
<dd><p>Computes the mean absolute error (see <a class="reference internal" href="#quapy.error.ae" title="quapy.error.ae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.ae()</span></code></a>) across the sample pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the predicted
prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.match_distance">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">match_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ERROR_TOL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.match_distance" title="Link to this definition"></a></dt>
<dd><p>Computes the Match Distance, under the assumption that the cost in mistaking class i with class i+1 is 1 in
all cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> or <cite>(n_instances, n_classes)</cite>  with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> or <cite>(n_instances, n_classes)</cite> with the predicted prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.md">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">md</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ERROR_TOL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#md"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.md" title="Link to this definition"></a></dt>
<dd><p>Computes the Match Distance, under the assumption that the cost in mistaking class i with class i+1 is 1 in
all cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> or <cite>(n_instances, n_classes)</cite>  with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> or <cite>(n_instances, n_classes)</cite> with the predicted prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.mean_absolute_error">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">mean_absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.mean_absolute_error" title="Link to this definition"></a></dt>
<dd><p>Computes the mean absolute error (see <a class="reference internal" href="#quapy.error.ae" title="quapy.error.ae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.ae()</span></code></a>) across the sample pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the predicted
prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.mean_normalized_absolute_error">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">mean_normalized_absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.mean_normalized_absolute_error" title="Link to this definition"></a></dt>
<dd><p>Computes the mean normalized absolute error (see <a class="reference internal" href="#quapy.error.nae" title="quapy.error.nae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.nae()</span></code></a>) across the sample pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the predicted
prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean normalized absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.mean_normalized_relative_absolute_error">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">mean_normalized_relative_absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.mean_normalized_relative_absolute_error" title="Link to this definition"></a></dt>
<dd><p>Computes the mean normalized relative absolute error (see <a class="reference internal" href="#quapy.error.nrae" title="quapy.error.nrae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.nrae()</span></code></a>) across
the sample pairs. The distributions are smoothed using the <cite>eps</cite> factor (see
<a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the true
prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the predicted
prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. <cite>mnrae</cite> is not defined in cases in which the true
distribution contains zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>,
with <span class="math notranslate nohighlight">\(T\)</span> the sample size. If <cite>eps=None</cite>, the sample size will be taken from
the environment variable <cite>SAMPLE_SIZE</cite> (which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean normalized relative absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.mean_relative_absolute_error">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">mean_relative_absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.mean_relative_absolute_error" title="Link to this definition"></a></dt>
<dd><p>Computes the mean relative absolute error (see <a class="reference internal" href="#quapy.error.rae" title="quapy.error.rae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.rae()</span></code></a>) across
the sample pairs. The distributions are smoothed using the <cite>eps</cite> factor (see
<a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the true
prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the predicted
prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. <cite>mrae</cite> is not defined in cases in which the true
distribution contains zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>,
with <span class="math notranslate nohighlight">\(T\)</span> the sample size. If <cite>eps=None</cite>, the sample size will be taken from
the environment variable <cite>SAMPLE_SIZE</cite> (which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean relative absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.mkld">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">mkld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#mkld"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.mkld" title="Link to this definition"></a></dt>
<dd><p>Computes the mean Kullback-Leibler divergence (see <a class="reference internal" href="#quapy.error.kld" title="quapy.error.kld"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.kld()</span></code></a>) across the
sample pairs. The distributions are smoothed using the <cite>eps</cite> factor
(see <a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the true
prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the predicted
prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. KLD is not defined in cases in which the distributions contain
zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>, with <span class="math notranslate nohighlight">\(T\)</span> the sample size.
If <cite>eps=None</cite>, the sample size will be taken from the environment variable <cite>SAMPLE_SIZE</cite>
(which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean Kullback-Leibler distribution</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.mnae">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">mnae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#mnae"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.mnae" title="Link to this definition"></a></dt>
<dd><p>Computes the mean normalized absolute error (see <a class="reference internal" href="#quapy.error.nae" title="quapy.error.nae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.nae()</span></code></a>) across the sample pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the predicted
prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean normalized absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.mnkld">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">mnkld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#mnkld"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.mnkld" title="Link to this definition"></a></dt>
<dd><p>Computes the mean Normalized Kullback-Leibler divergence (see <a class="reference internal" href="#quapy.error.nkld" title="quapy.error.nkld"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.nkld()</span></code></a>)
across the sample pairs. The distributions are smoothed using the <cite>eps</cite> factor
(see <a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the predicted
prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. NKLD is not defined in cases in which the distributions contain
zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>, with <span class="math notranslate nohighlight">\(T\)</span> the sample size.
If <cite>eps=None</cite>, the sample size will be taken from the environment variable <cite>SAMPLE_SIZE</cite>
(which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean Normalized Kullback-Leibler distribution</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.mnrae">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">mnrae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#mnrae"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.mnrae" title="Link to this definition"></a></dt>
<dd><p>Computes the mean normalized relative absolute error (see <a class="reference internal" href="#quapy.error.nrae" title="quapy.error.nrae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.nrae()</span></code></a>) across
the sample pairs. The distributions are smoothed using the <cite>eps</cite> factor (see
<a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the true
prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the predicted
prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. <cite>mnrae</cite> is not defined in cases in which the true
distribution contains zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>,
with <span class="math notranslate nohighlight">\(T\)</span> the sample size. If <cite>eps=None</cite>, the sample size will be taken from
the environment variable <cite>SAMPLE_SIZE</cite> (which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean normalized relative absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.mrae">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">mrae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#mrae"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.mrae" title="Link to this definition"></a></dt>
<dd><p>Computes the mean relative absolute error (see <a class="reference internal" href="#quapy.error.rae" title="quapy.error.rae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.rae()</span></code></a>) across
the sample pairs. The distributions are smoothed using the <cite>eps</cite> factor (see
<a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the true
prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the predicted
prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. <cite>mrae</cite> is not defined in cases in which the true
distribution contains zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>,
with <span class="math notranslate nohighlight">\(T\)</span> the sample size. If <cite>eps=None</cite>, the sample size will be taken from
the environment variable <cite>SAMPLE_SIZE</cite> (which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean relative absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.mse">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">mse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#mse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.mse" title="Link to this definition"></a></dt>
<dd><p>Computes the mean squared error (see <a class="reference internal" href="#quapy.error.se" title="quapy.error.se"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.se()</span></code></a>) across the sample pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the
true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_samples, n_classes,)</cite> with the
predicted prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean squared error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.nae">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">nae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#nae"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.nae" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes the normalized absolute error between the two prevalence vectors.</dt><dd><p>Normalized absolute error between two prevalence vectors <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\hat{p}\)</span>  is computed as
<span class="math notranslate nohighlight">\(NAE(p,\hat{p})=\frac{AE(p,\hat{p})}{z_{AE}}\)</span>,
where <span class="math notranslate nohighlight">\(z_{AE}=\frac{2(1-\min_{y\in \mathcal{Y}} p(y))}{|\mathcal{Y}|}\)</span>, and <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span>
are the classes of interest.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> with the predicted prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>normalized absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.nkld">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">nkld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#nkld"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.nkld" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes the Normalized Kullback-Leibler divergence between the two prevalence distributions.</dt><dd><p>Normalized Kullback-Leibler divergence between two prevalence distributions <span class="math notranslate nohighlight">\(p\)</span> and
<span class="math notranslate nohighlight">\(\hat{p}\)</span> is computed as
math:<cite>NKLD(p,hat{p}) = 2frac{e^{KLD(p,hat{p})}}{e^{KLD(p,hat{p})}+1}-1</cite>,
where
<span class="math notranslate nohighlight">\(\mathcal{Y}\)</span> are the classes of interest.
The distributions are smoothed using the <cite>eps</cite> factor (see <a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> with the predicted prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. NKLD is not defined in cases in which the distributions
contain zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>, with <span class="math notranslate nohighlight">\(T\)</span> the sample
size. If <cite>eps=None</cite>, the sample size will be taken from the environment variable
<cite>SAMPLE_SIZE</cite> (which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Normalized Kullback-Leibler divergence between the two distributions</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.nmd">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">nmd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#nmd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.nmd" title="Link to this definition"></a></dt>
<dd><p>Computes the Normalized Match Distance; which is the Normalized Distance multiplied by the factor
<cite>1/(n-1)</cite> to guarantee the measure ranges between 0 (best prediction) and 1 (worst prediction).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> or <cite>(n_instances, n_classes)</cite>  with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> or <cite>(n_instances, n_classes)</cite> with the predicted prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>float in [0,1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.normalized_absolute_error">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">normalized_absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.normalized_absolute_error" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes the normalized absolute error between the two prevalence vectors.</dt><dd><p>Normalized absolute error between two prevalence vectors <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\hat{p}\)</span>  is computed as
<span class="math notranslate nohighlight">\(NAE(p,\hat{p})=\frac{AE(p,\hat{p})}{z_{AE}}\)</span>,
where <span class="math notranslate nohighlight">\(z_{AE}=\frac{2(1-\min_{y\in \mathcal{Y}} p(y))}{|\mathcal{Y}|}\)</span>, and <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span>
are the classes of interest.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> with the predicted prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>normalized absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.normalized_match_distance">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">normalized_match_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.normalized_match_distance" title="Link to this definition"></a></dt>
<dd><p>Computes the Normalized Match Distance; which is the Normalized Distance multiplied by the factor
<cite>1/(n-1)</cite> to guarantee the measure ranges between 0 (best prediction) and 1 (worst prediction).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> or <cite>(n_instances, n_classes)</cite>  with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> or <cite>(n_instances, n_classes)</cite> with the predicted prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>float in [0,1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.normalized_relative_absolute_error">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">normalized_relative_absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.normalized_relative_absolute_error" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes the normalized absolute relative error between the two prevalence vectors.</dt><dd><p>Relative absolute error between two prevalence vectors <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\hat{p}\)</span>
is computed as
<span class="math notranslate nohighlight">\(NRAE(p,\hat{p})= \frac{RAE(p,\hat{p})}{z_{RAE}}\)</span>,
where
<span class="math notranslate nohighlight">\(z_{RAE} = \frac{|\mathcal{Y}|-1+\frac{1-\min_{y\in \mathcal{Y}} p(y)}{\min_{y\in \mathcal{Y}} p(y)}}{|\mathcal{Y}|}\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span> are the classes of interest.
The distributions are smoothed using the <cite>eps</cite> factor (see <a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> with the predicted prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. <cite>nrae</cite> is not defined in cases in which the true distribution
contains zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>, with <span class="math notranslate nohighlight">\(T\)</span> the
sample size. If <cite>eps=None</cite>, the sample size will be taken from the environment variable
<cite>SAMPLE_SIZE</cite> (which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>normalized relative absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.nrae">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">nrae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#nrae"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.nrae" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes the normalized absolute relative error between the two prevalence vectors.</dt><dd><p>Relative absolute error between two prevalence vectors <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\hat{p}\)</span>
is computed as
<span class="math notranslate nohighlight">\(NRAE(p,\hat{p})= \frac{RAE(p,\hat{p})}{z_{RAE}}\)</span>,
where
<span class="math notranslate nohighlight">\(z_{RAE} = \frac{|\mathcal{Y}|-1+\frac{1-\min_{y\in \mathcal{Y}} p(y)}{\min_{y\in \mathcal{Y}} p(y)}}{|\mathcal{Y}|}\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span> are the classes of interest.
The distributions are smoothed using the <cite>eps</cite> factor (see <a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> with the predicted prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. <cite>nrae</cite> is not defined in cases in which the true distribution
contains zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>, with <span class="math notranslate nohighlight">\(T\)</span> the
sample size. If <cite>eps=None</cite>, the sample size will be taken from the environment variable
<cite>SAMPLE_SIZE</cite> (which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>normalized relative absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.rae">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">rae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#rae"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.rae" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes the absolute relative error between the two prevalence vectors.</dt><dd><p>Relative absolute error between two prevalence vectors <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\hat{p}\)</span>
is computed as
<span class="math notranslate nohighlight">\(RAE(p,\hat{p})=
\frac{1}{|\mathcal{Y}|}\sum_{y\in \mathcal{Y}}\frac{|\hat{p}(y)-p(y)|}{p(y)}\)</span>,
where <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span> are the classes of interest.
The distributions are smoothed using the <cite>eps</cite> factor (see <a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> with the predicted prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. <cite>rae</cite> is not defined in cases in which the true distribution
contains zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>, with <span class="math notranslate nohighlight">\(T\)</span> the
sample size. If <cite>eps=None</cite>, the sample size will be taken from the environment variable
<cite>SAMPLE_SIZE</cite> (which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>relative absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.relative_absolute_error">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">relative_absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.error.relative_absolute_error" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes the absolute relative error between the two prevalence vectors.</dt><dd><p>Relative absolute error between two prevalence vectors <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\hat{p}\)</span>
is computed as
<span class="math notranslate nohighlight">\(RAE(p,\hat{p})=
\frac{1}{|\mathcal{Y}|}\sum_{y\in \mathcal{Y}}\frac{|\hat{p}(y)-p(y)|}{p(y)}\)</span>,
where <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span> are the classes of interest.
The distributions are smoothed using the <cite>eps</cite> factor (see <a class="reference internal" href="#quapy.error.smooth" title="quapy.error.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.smooth()</span></code></a>).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> with the predicted prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor. <cite>rae</cite> is not defined in cases in which the true distribution
contains zeros; <cite>eps</cite> is typically set to be <span class="math notranslate nohighlight">\(\frac{1}{2T}\)</span>, with <span class="math notranslate nohighlight">\(T\)</span> the
sample size. If <cite>eps=None</cite>, the sample size will be taken from the environment variable
<cite>SAMPLE_SIZE</cite> (which has thus to be set beforehand).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>relative absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.se">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">se</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_hat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#se"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.se" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes the squared error between the two prevalence vectors.</dt><dd><p>Squared error between two prevalence vectors <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\hat{p}\)</span>  is computed as
<span class="math notranslate nohighlight">\(SE(p,\hat{p})=\frac{1}{|\mathcal{Y}|}\sum_{y\in \mathcal{Y}}(\hat{p}(y)-p(y))^2\)</span>,
where
<span class="math notranslate nohighlight">\(\mathcal{Y}\)</span> are the classes of interest.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>prevs_hat</strong> – array-like of shape <cite>(n_classes,)</cite> with the predicted prevalence values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>absolute error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.error.smooth">
<span class="sig-prename descclassname"><span class="pre">quapy.error.</span></span><span class="sig-name descname"><span class="pre">smooth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/error.html#smooth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.error.smooth" title="Link to this definition"></a></dt>
<dd><p>Smooths a prevalence distribution with <span class="math notranslate nohighlight">\(\epsilon\)</span> (<cite>eps</cite>) as:
<span class="math notranslate nohighlight">\(\underline{p}(y)=\frac{\epsilon+p(y)}{\epsilon|\mathcal{Y}|+
\displaystyle\sum_{y\in \mathcal{Y}}p(y)}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevs</strong> – array-like of shape <cite>(n_classes,)</cite> with the true prevalence values</p></li>
<li><p><strong>eps</strong> – smoothing factor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>array-like of shape <cite>(n_classes,)</cite> with the smoothed distribution</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-quapy.evaluation">
<span id="quapy-evaluation-module"></span><h2>quapy.evaluation module<a class="headerlink" href="#module-quapy.evaluation" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="quapy.evaluation.evaluate">
<span class="sig-prename descclassname"><span class="pre">quapy.evaluation.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><span class="pre">BaseQuantifier</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#quapy.protocol.AbstractProtocol" title="quapy.protocol.AbstractProtocol"><span class="pre">AbstractProtocol</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_metric</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggr_speedup</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/evaluation.html#evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.evaluation.evaluate" title="Link to this definition"></a></dt>
<dd><p>Evaluates a quantification model according to a specific sample generation protocol and in terms of one
evaluation metric (error).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – a quantifier, instance of <a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.method.base.BaseQuantifier</span></code></a></p></li>
<li><p><strong>protocol</strong> – <a class="reference internal" href="#quapy.protocol.AbstractProtocol" title="quapy.protocol.AbstractProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.protocol.AbstractProtocol</span></code></a>; if this object is also instance of
<a class="reference internal" href="#quapy.protocol.OnLabelledCollectionProtocol" title="quapy.protocol.OnLabelledCollectionProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.protocol.OnLabelledCollectionProtocol</span></code></a>, then the aggregation speed-up can be run. This is the
protocol in charge of generating the samples in which the model is evaluated.</p></li>
<li><p><strong>error_metric</strong> – a string representing the name(s) of an error function in <cite>qp.error</cite>
(e.g., ‘mae’), or a callable function implementing the error function itself.</p></li>
<li><p><strong>aggr_speedup</strong> – whether or not to apply the speed-up. Set to “force” for applying it even if the number of
instances in the original collection on which the protocol acts is larger than the number of instances
in the samples to be generated. Set to True or “auto” (default) for letting QuaPy decide whether it is
convenient or not. Set to False to deactivate.</p></li>
<li><p><strong>verbose</strong> – boolean, show or not information in stdout</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>if the error metric is not averaged (e.g., ‘ae’, ‘rae’), returns an array of shape <cite>(n_samples,)</cite> with
the error scores for each sample; if the error metric is averaged (e.g., ‘mae’, ‘mrae’) then returns
a single float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.evaluation.evaluate_on_samples">
<span class="sig-prename descclassname"><span class="pre">quapy.evaluation.</span></span><span class="sig-name descname"><span class="pre">evaluate_on_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><span class="pre">BaseQuantifier</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_metric</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/evaluation.html#evaluate_on_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.evaluation.evaluate_on_samples" title="Link to this definition"></a></dt>
<dd><p>Evaluates a quantification model on a given set of samples and in terms of one evaluation metric (error).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – a quantifier, instance of <a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.method.base.BaseQuantifier</span></code></a></p></li>
<li><p><strong>samples</strong> – a list of samples on which the quantifier is to be evaluated</p></li>
<li><p><strong>error_metric</strong> – a string representing the name(s) of an error function in <cite>qp.error</cite>
(e.g., ‘mae’), or a callable function implementing the error function itself.</p></li>
<li><p><strong>verbose</strong> – boolean, show or not information in stdout</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>if the error metric is not averaged (e.g., ‘ae’, ‘rae’), returns an array of shape <cite>(n_samples,)</cite> with
the error scores for each sample; if the error metric is averaged (e.g., ‘mae’, ‘mrae’) then returns
a single float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.evaluation.evaluation_report">
<span class="sig-prename descclassname"><span class="pre">quapy.evaluation.</span></span><span class="sig-name descname"><span class="pre">evaluation_report</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><span class="pre">BaseQuantifier</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#quapy.protocol.AbstractProtocol" title="quapy.protocol.AbstractProtocol"><span class="pre">AbstractProtocol</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_metrics</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'mae'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggr_speedup</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/evaluation.html#evaluation_report"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.evaluation.evaluation_report" title="Link to this definition"></a></dt>
<dd><p>Generates a report (a pandas’ DataFrame) containing information of the evaluation of the model as according
to a specific protocol and in terms of one or more evaluation metrics (errors).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – a quantifier, instance of <a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.method.base.BaseQuantifier</span></code></a></p></li>
<li><p><strong>protocol</strong> – <a class="reference internal" href="#quapy.protocol.AbstractProtocol" title="quapy.protocol.AbstractProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.protocol.AbstractProtocol</span></code></a>; if this object is also instance of
<a class="reference internal" href="#quapy.protocol.OnLabelledCollectionProtocol" title="quapy.protocol.OnLabelledCollectionProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.protocol.OnLabelledCollectionProtocol</span></code></a>, then the aggregation speed-up can be run. This is the protocol
in charge of generating the samples in which the model is evaluated.</p></li>
<li><p><strong>error_metrics</strong> – a string, or list of strings, representing the name(s) of an error function in <cite>qp.error</cite>
(e.g., ‘mae’, the default value), or a callable function, or a list of callable functions, implementing
the error function itself.</p></li>
<li><p><strong>aggr_speedup</strong> – whether or not to apply the speed-up. Set to “force” for applying it even if the number of
instances in the original collection on which the protocol acts is larger than the number of instances
in the samples to be generated. Set to True or “auto” (default) for letting QuaPy decide whether it is
convenient or not. Set to False to deactivate.</p></li>
<li><p><strong>verbose</strong> – boolean, show or not information in stdout</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a pandas’ DataFrame containing the columns ‘true-prev’ (the true prevalence of each sample),
‘estim-prev’ (the prevalence estimated by the model for each sample), and as many columns as error metrics
have been indicated, each displaying the score in terms of that metric for every sample.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.evaluation.prediction">
<span class="sig-prename descclassname"><span class="pre">quapy.evaluation.</span></span><span class="sig-name descname"><span class="pre">prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><span class="pre">BaseQuantifier</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#quapy.protocol.AbstractProtocol" title="quapy.protocol.AbstractProtocol"><span class="pre">AbstractProtocol</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggr_speedup</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/evaluation.html#prediction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.evaluation.prediction" title="Link to this definition"></a></dt>
<dd><p>Uses a quantification model to generate predictions for the samples generated via a specific protocol.
This function is central to all evaluation processes, and is endowed with an optimization to speed-up the
prediction of protocols that generate samples from a large collection. The optimization applies to aggregative
quantifiers only, and to OnLabelledCollectionProtocol protocols, and comes down to generating the classification
predictions once and for all, and then generating samples over the classification predictions (instead of over
the raw instances), so that the classifier prediction is never called again. This behaviour is obtained by
setting <cite>aggr_speedup</cite> to ‘auto’ or True, and is only carried out if the overall process is convenient in terms
of computations (e.g., if the number of classification predictions needed for the original collection exceed the
number of classification predictions needed for all samples, then the optimization is not undertaken).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – a quantifier, instance of <a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.method.base.BaseQuantifier</span></code></a></p></li>
<li><p><strong>protocol</strong> – <a class="reference internal" href="#quapy.protocol.AbstractProtocol" title="quapy.protocol.AbstractProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.protocol.AbstractProtocol</span></code></a>; if this object is also instance of
<a class="reference internal" href="#quapy.protocol.OnLabelledCollectionProtocol" title="quapy.protocol.OnLabelledCollectionProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.protocol.OnLabelledCollectionProtocol</span></code></a>, then the aggregation speed-up can be run. This is the protocol
in charge of generating the samples for which the model has to issue class prevalence predictions.</p></li>
<li><p><strong>aggr_speedup</strong> – whether or not to apply the speed-up. Set to “force” for applying it even if the number of
instances in the original collection on which the protocol acts is larger than the number of instances
in the samples to be generated. Set to True or “auto” (default) for letting QuaPy decide whether it is
convenient or not. Set to False to deactivate.</p></li>
<li><p><strong>verbose</strong> – boolean, show or not information in stdout</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tuple <cite>(true_prevs, estim_prevs)</cite> in which each element in the tuple is an array of shape
<cite>(n_samples, n_classes)</cite> containing the true, or predicted, prevalence values for each sample</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-quapy.functional">
<span id="quapy-functional-module"></span><h2>quapy.functional module<a class="headerlink" href="#module-quapy.functional" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.HellingerDistance">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">HellingerDistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#HellingerDistance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.HellingerDistance" title="Link to this definition"></a></dt>
<dd><p>Computes the Hellingher Distance (HD) between (discretized) distributions <cite>P</cite> and <cite>Q</cite>.
The HD for two discrete distributions of <cite>k</cite> bins is defined as:</p>
<div class="math notranslate nohighlight">
\[HD(P,Q) = \frac{ 1 }{ \sqrt{ 2 } } \sqrt{ \sum_{i=1}^k ( \sqrt{p_i} - \sqrt{q_i} )^2 }\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>P</strong> – real-valued array-like of shape <cite>(k,)</cite> representing a discrete distribution</p></li>
<li><p><strong>Q</strong> – real-valued array-like of shape <cite>(k,)</cite> representing a discrete distribution</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.TopsoeDistance">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">TopsoeDistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-20</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#TopsoeDistance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.TopsoeDistance" title="Link to this definition"></a></dt>
<dd><p>Topsoe distance between two (discretized) distributions <cite>P</cite> and <cite>Q</cite>.
The Topsoe distance for two discrete distributions of <cite>k</cite> bins is defined as:</p>
<div class="math notranslate nohighlight">
\[Topsoe(P,Q) = \sum_{i=1}^k \left( p_i \log\left(\frac{ 2 p_i + \epsilon }{ p_i+q_i+\epsilon }\right) +
    q_i \log\left(\frac{ 2 q_i + \epsilon }{ p_i+q_i+\epsilon }\right) \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>P</strong> – real-valued array-like of shape <cite>(k,)</cite> representing a discrete distribution</p></li>
<li><p><strong>Q</strong> – real-valued array-like of shape <cite>(k,)</cite> representing a discrete distribution</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.argmin_prevalence">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">argmin_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loss</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'optim_minimize'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'linear_search'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'ternary_search'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'optim_minimize'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#argmin_prevalence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.argmin_prevalence" title="Link to this definition"></a></dt>
<dd><p>Searches for the prevalence vector that minimizes a loss function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loss</strong> – callable, the function to minimize</p></li>
<li><p><strong>n_classes</strong> – int, number of classes</p></li>
<li><p><strong>method</strong> – string indicating the search strategy. Possible values are::
‘optim_minimize’: uses scipy.optim
‘linear_search’: carries out a linear search for binary problems in the space [0, 0.01, 0.02, …, 1]
‘ternary_search’: implements the ternary search (not yet implemented)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray, a prevalence vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.as_binary_prevalence">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">as_binary_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positive_prevalence</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip_if_necessary</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#as_binary_prevalence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.as_binary_prevalence" title="Link to this definition"></a></dt>
<dd><p>Helper that, given a float representing the prevalence for the positive class, returns a np.ndarray of two
values representing a binary distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positive_prevalence</strong> – float or array-like of floats with the prevalence for the positive class</p></li>
<li><p><strong>clip_if_necessary</strong> (<em>bool</em>) – if True, clips the value in [0,1] in order to guarantee the resulting distribution
is valid. If False, it then checks that the value is in the valid range, and raises an error if not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray of shape <cite>(2,)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.check_prevalence_vector">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">check_prevalence_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalences</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_exception</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#check_prevalence_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.check_prevalence_vector" title="Link to this definition"></a></dt>
<dd><p>Checks that <cite>prevalences</cite> is a valid prevalence vector, i.e., it contains values in [0,1] and
the values sum up to 1. In other words, verifies that the <cite>prevalences</cite> vectors lies in the
probability simplex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevalences</strong> (<em>ArrayLike</em>) – the prevalence vector, or vectors, to check</p></li>
<li><p><strong>raise_exception</strong> (<em>bool</em>) – whether to raise an exception if the vector (or any of the vectors) does
not lie in the simplex (default False)</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – error tolerance for the check <cite>sum(prevalences) - 1 = 0</cite></p></li>
<li><p><strong>aggr</strong> (<em>bool</em>) – if True (default) returns one single bool (True if all prevalence vectors are valid,
False otherwise), if False returns an array of bool, one for each prevalence vector</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a single bool True if <cite>prevalences</cite> is a vector of prevalence values that lies on the simplex,
or False otherwise; alternatively, if <cite>prevalences</cite> is a matrix of shape <cite>(num_vectors, n_classes,)</cite>
then it returns one such bool for each prevalence vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.clip">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">clip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalences</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#clip"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.clip" title="Link to this definition"></a></dt>
<dd><p>Clips the values in [0,1] and then applies the L1 normalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prevalences</strong> – array-like of shape <cite>(n_classes,)</cite> or of shape <cite>(n_samples, n_classes,)</cite> with prevalence values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray representing a valid distribution</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.condsoftmax">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">condsoftmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalences</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#condsoftmax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.condsoftmax" title="Link to this definition"></a></dt>
<dd><p>Applies the softmax function only to vectors that do not represent valid distributions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prevalences</strong> – array-like of shape <cite>(n_classes,)</cite> or of shape <cite>(n_samples, n_classes,)</cite> with prevalence values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray representing a valid distribution</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.counts_from_labels">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">counts_from_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#counts_from_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.counts_from_labels" title="Link to this definition"></a></dt>
<dd><p>Computes the raw count values from a vector of labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> – array-like of shape <cite>(n_instances,)</cite> with the label for each instance</p></li>
<li><p><strong>classes</strong> – the class labels. This is needed in order to correctly compute the prevalence vector even when
some classes have no examples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray of shape <cite>(len(classes),)</cite> with the raw counts for each class, in the same order
as they appear in <cite>classes</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.get_divergence">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">get_divergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">divergence</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#get_divergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.get_divergence" title="Link to this definition"></a></dt>
<dd><p>Guarantees that the divergence received as argument is a function. That is, if this argument is already
a callable, then it is returned, if it is instead a string, then tries to instantiate the corresponding
divergence from the string name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>divergence</strong> – callable or string indicating the name of the divergence function</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>callable</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.get_nprevpoints_approximation">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">get_nprevpoints_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">combinations_budget</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_repeats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#get_nprevpoints_approximation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.get_nprevpoints_approximation" title="Link to this definition"></a></dt>
<dd><p>Searches for the largest number of (equidistant) prevalence points to define for each of the <cite>n_classes</cite> classes so
that the number of valid prevalence values generated as combinations of prevalence points (points in a
<cite>n_classes</cite>-dimensional simplex) do not exceed combinations_budget.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>combinations_budget</strong> (<em>int</em>) – maximum number of combinations allowed</p></li>
<li><p><strong>n_classes</strong> (<em>int</em>) – number of classes</p></li>
<li><p><strong>n_repeats</strong> (<em>int</em>) – number of repetitions for each prevalence combination</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the largest number of prevalence points that generate less than combinations_budget valid prevalences</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.l1_norm">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">l1_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalences</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#l1_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.l1_norm" title="Link to this definition"></a></dt>
<dd><p>Applies L1 normalization to the <cite>unnormalized_arr</cite> so that it becomes a valid prevalence
vector. Zero vectors are mapped onto the uniform distribution. Raises an exception if
the resulting vectors are not valid distributions. This may happen when the original
prevalence vectors contain negative values. Use the <cite>clip</cite> normalization function
instead to avoid this possibility.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prevalences</strong> – array-like of shape <cite>(n_classes,)</cite> or of shape <cite>(n_samples, n_classes,)</cite> with prevalence values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray representing a valid distribution</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.linear_search">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">linear_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loss</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#linear_search"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.linear_search" title="Link to this definition"></a></dt>
<dd><p>Performs a linear search for the best prevalence value in binary problems. The search is carried out by exploring
the range [0,1] stepping by 0.01. This search is inefficient, and is added only for completeness (some of the
early methods in quantification literature used it, e.g., HDy). A most powerful alternative is <cite>optim_minimize</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loss</strong> – (callable) the function to minimize</p></li>
<li><p><strong>n_classes</strong> – (int) the number of classes, i.e., the dimensionality of the prevalence vector</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(ndarray) the best prevalence vector found</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.normalize_prevalence">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">normalize_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalences</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'l1'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#normalize_prevalence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.normalize_prevalence" title="Link to this definition"></a></dt>
<dd><p>Normalizes a vector or matrix of prevalence values. The normalization consists of applying a L1 normalization in
cases in which the prevalence values are not all-zeros, and to convert the prevalence values into <cite>1/n_classes</cite> in
cases in which all values are zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevalences</strong> – array-like of shape <cite>(n_classes,)</cite> or of shape <cite>(n_samples, n_classes,)</cite> with prevalence values</p></li>
<li><p><strong>method</strong> (<em>str</em>) – <p>indicates the normalization method to employ, options are:</p>
<ul>
<li><p><cite>l1</cite>: applies L1 normalization (default); a 0 vector is mapped onto the uniform prevalence</p></li>
<li><p><cite>clip</cite>: clip values in [0,1] and then rescales so that the L1 norm is 1</p></li>
<li><p><cite>mapsimplex</cite>: projects vectors onto the probability simplex. This implementation relies on
<a class="reference external" href="https://gist.github.com/mblondel/6f3b7aaad90606b98f71">Mathieu Blondel’s projection_simplex_sort</a></p></li>
<li><p><cite>softmax</cite>: applies softmax to all vectors</p></li>
<li><p><cite>condsoftmax</cite>: applies softmax only to invalid prevalence vectors</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a normalized vector or matrix of prevalence values</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.num_prevalence_combinations">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">num_prevalence_combinations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_prevpoints</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_repeats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#num_prevalence_combinations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.num_prevalence_combinations" title="Link to this definition"></a></dt>
<dd><p>Computes the number of valid prevalence combinations in the n_classes-dimensional simplex if <cite>n_prevpoints</cite> equally
distant prevalence values are generated and <cite>n_repeats</cite> repetitions are requested.
The computation comes down to calculating:</p>
<div class="math notranslate nohighlight">
\[\binom{N+C-1}{C-1} \times r\]</div>
<p>where <cite>N</cite> is <cite>n_prevpoints-1</cite>, i.e., the number of probability mass blocks to allocate, <cite>C</cite> is the number of
classes, and <cite>r</cite> is <cite>n_repeats</cite>. This solution comes from the
<a class="reference external" href="https://brilliant.org/wiki/integer-equations-star-and-bars/">Stars and Bars</a> problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_classes</strong> (<em>int</em>) – number of classes</p></li>
<li><p><strong>n_prevpoints</strong> (<em>int</em>) – number of prevalence points.</p></li>
<li><p><strong>n_repeats</strong> (<em>int</em>) – number of repetitions for each prevalence combination</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of possible combinations. For example, if <a href="#id1"><span class="problematic" id="id2">`</span></a>n_classes`=2, <a href="#id3"><span class="problematic" id="id4">`</span></a>n_prevpoints`=5, <a href="#id5"><span class="problematic" id="id6">`</span></a>n_repeats`=1,
then the number of possible combinations are 5, i.e.: [0,1], [0.25,0.75], [0.50,0.50], [0.75,0.25],
and [1.0,0.0]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.optim_minimize">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">optim_minimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loss</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#optim_minimize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.optim_minimize" title="Link to this definition"></a></dt>
<dd><p>Searches for the optimal prevalence values, i.e., an <cite>n_classes</cite>-dimensional vector of the (<cite>n_classes</cite>-1)-simplex
that yields the smallest lost. This optimization is carried out by means of a constrained search using scipy’s
SLSQP routine.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loss</strong> – (callable) the function to minimize</p></li>
<li><p><strong>n_classes</strong> – (int) the number of classes, i.e., the dimensionality of the prevalence vector</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(ndarray) the best prevalence vector found</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.prevalence_from_labels">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">prevalence_from_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#prevalence_from_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.prevalence_from_labels" title="Link to this definition"></a></dt>
<dd><p>Computes the prevalence values from a vector of labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> – array-like of shape <cite>(n_instances,)</cite> with the label for each instance</p></li>
<li><p><strong>classes</strong> – the class labels. This is needed in order to correctly compute the prevalence vector even when
some classes have no examples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray of shape <cite>(len(classes),)</cite> with the class proportions for each class, in the same order
as they appear in <cite>classes</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.prevalence_from_probabilities">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">prevalence_from_probabilities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posteriors</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binarize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#prevalence_from_probabilities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.prevalence_from_probabilities" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of prevalence values from a matrix of posterior probabilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>posteriors</strong> – array-like of shape <cite>(n_instances, n_classes,)</cite> with posterior probabilities for each class</p></li>
<li><p><strong>binarize</strong> – set to True (default is False) for computing the prevalence values on crisp decisions (i.e.,
converting the vectors of posterior probabilities into class indices, by taking the argmax).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>array of shape <cite>(n_classes,)</cite> containing the prevalence values</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.prevalence_linspace">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">prevalence_linspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">21</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_limits_epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#prevalence_linspace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.prevalence_linspace" title="Link to this definition"></a></dt>
<dd><p>Produces an array of uniformly separated values of prevalence.
By default, produces an array of 21 prevalence values, with
step 0.05 and with the limits smoothed, i.e.:
[0.01, 0.05, 0.10, 0.15, …, 0.90, 0.95, 0.99]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid_points</strong> – the number of prevalence values to sample from the [0,1] interval (default 21)</p></li>
<li><p><strong>repeats</strong> – number of times each prevalence is to be repeated (defaults to 1)</p></li>
<li><p><strong>smooth_limits_epsilon</strong> – the quantity to add and subtract to the limits 0 and 1</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an array of uniformly separated prevalence values</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.projection_simplex_sort">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">projection_simplex_sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unnormalized_arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#projection_simplex_sort"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.projection_simplex_sort" title="Link to this definition"></a></dt>
<dd><p>Projects a point onto the probability simplex.</p>
<p>The code is adapted from Mathieu Blondel’s BSD-licensed
<a class="reference external" href="https://gist.github.com/mblondel/6f3b7aaad90606b98f71">implementation</a>
(see function <cite>projection_simplex_sort</cite> in their repo) which is accompanying the paper</p>
<p>Mathieu Blondel, Akinori Fujino, and Naonori Ueda.
Large-scale Multiclass Support Vector Machine Training via Euclidean Projection onto the Simplex,
ICPR 2014, <a class="reference external" href="http://www.mblondel.org/publications/mblondel-icpr2014.pdf">URL</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>unnormalized_arr</strong> – point in n-dimensional space, shape <cite>(n,)</cite></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>projection of <cite>unnormalized_arr</cite> onto the (n-1)-dimensional probability simplex, shape <cite>(n,)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.softmax">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">softmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalences</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#softmax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.softmax" title="Link to this definition"></a></dt>
<dd><p>Applies the softmax function to all vectors even if the original vectors were valid distributions.
If you want to leave valid vectors untouched, use condsoftmax instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prevalences</strong> – array-like of shape <cite>(n_classes,)</cite> or of shape <cite>(n_samples, n_classes,)</cite> with prevalence values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray representing a valid distribution</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.solve_adjustment">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">solve_adjustment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_conditional_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unadjusted_counts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'inversion'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'invariant-ratio'</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'exact'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'minimize'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'exact-raise'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'exact-cc'</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#solve_adjustment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.solve_adjustment" title="Link to this definition"></a></dt>
<dd><p>Function that tries to solve for <span class="math notranslate nohighlight">\(p\)</span> the equation <span class="math notranslate nohighlight">\(q = M p\)</span>, where <span class="math notranslate nohighlight">\(q\)</span> is the vector of
<cite>unadjusted counts</cite> (as estimated, e.g., via classify and count) with <span class="math notranslate nohighlight">\(q_i\)</span> an estimate of
<span class="math notranslate nohighlight">\(P(\hat{Y}=y_i)\)</span>, and where <span class="math notranslate nohighlight">\(M\)</span> is the matrix of <cite>class-conditional rates</cite> with <span class="math notranslate nohighlight">\(M_{ij}\)</span> an
estimate of <span class="math notranslate nohighlight">\(P(\hat{Y}=y_i|Y=y_j)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_conditional_rates</strong> – array of shape <cite>(n_classes, n_classes,)</cite> with entry <cite>(i,j)</cite> being the estimate
of <span class="math notranslate nohighlight">\(P(\hat{Y}=y_i|Y=y_j)\)</span>, that is, the probability that an instance that belongs to class <span class="math notranslate nohighlight">\(y_j\)</span>
ends up being classified as belonging to class <span class="math notranslate nohighlight">\(y_i\)</span></p></li>
<li><p><strong>unadjusted_counts</strong> – array of shape <cite>(n_classes,)</cite> containing the unadjusted prevalence values (e.g., as
estimated by CC or PCC)</p></li>
<li><p><strong>method</strong> (<em>str</em>) – <p>indicates the adjustment method to be used. Valid options are:</p>
<ul>
<li><p><cite>inversion</cite>: tries to solve the equation <span class="math notranslate nohighlight">\(q = M p\)</span> as <span class="math notranslate nohighlight">\(p = M^{-1} q\)</span> where
<span class="math notranslate nohighlight">\(M^{-1}\)</span> is the matrix inversion of <span class="math notranslate nohighlight">\(M\)</span>. This inversion may not exist in
degenerated cases.</p></li>
<li><p><cite>invariant-ratio</cite>: invariant ratio estimator of <a class="reference external" href="https://jmlr.org/papers/v20/18-456.html">Vaz et al. 2018</a>,
which replaces the last equation in <span class="math notranslate nohighlight">\(M\)</span> with the normalization condition (i.e., that the sum of
all prevalence values must equal 1).</p></li>
</ul>
</p></li>
<li><p><strong>solver</strong> (<em>str</em>) – <p>the method to use for solving the system of linear equations. Valid options are:</p>
<ul>
<li><p><cite>exact-raise</cite>: tries to solve the system using matrix inversion. Raises an error if the matrix has rank
strictly lower than <cite>n_classes</cite>.</p></li>
<li><p><cite>exact-cc</cite>: if the matrix is not full rank, returns <span class="math notranslate nohighlight">\(q\)</span> (i.e., the unadjusted counts) as the estimates</p></li>
<li><p><cite>exact</cite>: deprecated, defaults to ‘exact-cc’ (will be removed in future versions)</p></li>
<li><p><cite>minimize</cite>: minimizes a loss, so the solution always exists</p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.solve_adjustment_binary">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">solve_adjustment_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalence_estim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tpr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fpr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#solve_adjustment_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.solve_adjustment_binary" title="Link to this definition"></a></dt>
<dd><p>Implements the adjustment of ACC and PACC for the binary case. The adjustment for a prevalence estimate of the
positive class <cite>p</cite> comes down to computing:</p>
<div class="math notranslate nohighlight">
\[ACC(p) = \frac{ p - fpr }{ tpr - fpr }\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevalence_estim</strong> (<em>float</em>) – the estimated value for the positive class (<cite>p</cite> in the formula)</p></li>
<li><p><strong>tpr</strong> (<em>float</em>) – the true positive rate of the classifier</p></li>
<li><p><strong>fpr</strong> (<em>float</em>) – the false positive rate of the classifier</p></li>
<li><p><strong>clip</strong> (<em>bool</em>) – set to True (default) to clip values that might exceed the range [0,1]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>float, the adjusted count</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.strprev">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">strprev</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalences</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#strprev"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.strprev" title="Link to this definition"></a></dt>
<dd><p>Returns a string representation for a prevalence vector. E.g.,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strprev</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span> <span class="n">prec</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;[0.33, 0.67]&#39;</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prevalences</strong> – array-like of prevalence values</p></li>
<li><p><strong>prec</strong> – int, indicates the float precision (number of decimal values to print)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.ternary_search">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">ternary_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loss</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#ternary_search"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.ternary_search" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.uniform_prevalence">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">uniform_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_classes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/functional.html#uniform_prevalence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.uniform_prevalence" title="Link to this definition"></a></dt>
<dd><p>Returns a vector representing the uniform distribution for <cite>n_classes</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n_classes</strong> – number of classes</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray with all values 1/n_classes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.uniform_prevalence_sampling">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">uniform_prevalence_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/quapy/functional.html#uniform_prevalence_sampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.functional.uniform_prevalence_sampling" title="Link to this definition"></a></dt>
<dd><p>Implements the <a class="reference external" href="http://www.cs.cmu.edu/~nasmith/papers/smith+tromble.tr04.pdf">Kraemer algorithm</a>
for sampling uniformly at random from the unit simplex. This implementation is adapted from this
<cite>post &lt;https://cs.stackexchange.com/questions/3227/uniform-sampling-from-a-simplex&gt;_</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_classes</strong> – integer, number of classes (dimensionality of the simplex)</p></li>
<li><p><strong>size</strong> – number of samples to return</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(size, n_classes,)</cite> if <cite>size&gt;1</cite>, or of shape <cite>(n_classes,)</cite> otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.functional.uniform_simplex_sampling">
<span class="sig-prename descclassname"><span class="pre">quapy.functional.</span></span><span class="sig-name descname"><span class="pre">uniform_simplex_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#quapy.functional.uniform_simplex_sampling" title="Link to this definition"></a></dt>
<dd><p>Implements the <a class="reference external" href="http://www.cs.cmu.edu/~nasmith/papers/smith+tromble.tr04.pdf">Kraemer algorithm</a>
for sampling uniformly at random from the unit simplex. This implementation is adapted from this
<cite>post &lt;https://cs.stackexchange.com/questions/3227/uniform-sampling-from-a-simplex&gt;_</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_classes</strong> – integer, number of classes (dimensionality of the simplex)</p></li>
<li><p><strong>size</strong> – number of samples to return</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(size, n_classes,)</cite> if <cite>size&gt;1</cite>, or of shape <cite>(n_classes,)</cite> otherwise</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-quapy.model_selection">
<span id="quapy-model-selection-module"></span><h2>quapy.model_selection module<a class="headerlink" href="#module-quapy.model_selection" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="quapy.model_selection.ConfigStatus">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.model_selection.</span></span><span class="sig-name descname"><span class="pre">ConfigStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#ConfigStatus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.ConfigStatus" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.model_selection.ConfigStatus.failed">
<span class="sig-name descname"><span class="pre">failed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#ConfigStatus.failed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.ConfigStatus.failed" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.model_selection.ConfigStatus.success">
<span class="sig-name descname"><span class="pre">success</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#ConfigStatus.success"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.ConfigStatus.success" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.model_selection.GridSearchQ">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.model_selection.</span></span><span class="sig-name descname"><span class="pre">GridSearchQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model:</span> <span class="pre">~quapy.method.base.BaseQuantifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_grid:</span> <span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol:</span> <span class="pre">~quapy.protocol.AbstractProtocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error:</span> <span class="pre">~typing.Callable</span> <span class="pre">|</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">mae&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refit=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout=-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_errors=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#GridSearchQ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.GridSearchQ" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseQuantifier</span></code></a></p>
<p>Grid Search optimization targeting a quantification-oriented metric.</p>
<p>Optimizes the hyperparameters of a quantification method, based on an evaluation method and on an evaluation
protocol for quantification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><em>BaseQuantifier</em></a>) – the quantifier to optimize</p></li>
<li><p><strong>param_grid</strong> – a dictionary with keys the parameter names and values the list of values to explore</p></li>
<li><p><strong>protocol</strong> – a sample generation protocol, an instance of <a class="reference internal" href="#quapy.protocol.AbstractProtocol" title="quapy.protocol.AbstractProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.protocol.AbstractProtocol</span></code></a></p></li>
<li><p><strong>error</strong> – an error function (callable) or a string indicating the name of an error function (valid ones
are those in <code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.error.QUANTIFICATION_ERROR</span></code></p></li>
<li><p><strong>refit</strong> – whether to refit the model on the whole labelled collection (training+validation) with
the best chosen hyperparameter combination. Ignored if protocol=’gen’</p></li>
<li><p><strong>timeout</strong> – establishes a timer (in seconds) for each of the hyperparameters configurations being tested.
Whenever a run takes longer than this timer, that configuration will be ignored. If all configurations end up
being ignored, a TimeoutError exception is raised. If -1 (default) then no time bound is set.</p></li>
<li><p><strong>raise_errors</strong> – boolean, if True then raises an exception when a param combination yields any error, if
otherwise is False (default), then the combination is marked with an error status, but the process goes on.
However, if no configuration yields a valid model, then a ValueError exception will be raised.</p></li>
<li><p><strong>verbose</strong> – set to True to get information through the stdout</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.model_selection.GridSearchQ.best_model">
<span class="sig-name descname"><span class="pre">best_model</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#GridSearchQ.best_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.GridSearchQ.best_model" title="Link to this definition"></a></dt>
<dd><p>Returns the best model found after calling the <a class="reference internal" href="#quapy.model_selection.GridSearchQ.fit" title="quapy.model_selection.GridSearchQ.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> method, i.e., the one trained on the combination
of hyper-parameters that minimized the error function.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a trained quantifier</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.model_selection.GridSearchQ.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#GridSearchQ.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.GridSearchQ.fit" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Learning routine. Fits methods with all combinations of hyperparameters and selects the one minimizing</dt><dd><p>the error metric.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>training</strong> – the training set on which to optimize the hyperparameters</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.model_selection.GridSearchQ.get_params">
<span class="sig-name descname"><span class="pre">get_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#GridSearchQ.get_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.GridSearchQ.get_params" title="Link to this definition"></a></dt>
<dd><p>Returns the dictionary of hyper-parameters to explore (<cite>param_grid</cite>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>deep</strong> – Unused</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the dictionary <cite>param_grid</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.model_selection.GridSearchQ.quantify">
<span class="sig-name descname"><span class="pre">quantify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#GridSearchQ.quantify"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.GridSearchQ.quantify" title="Link to this definition"></a></dt>
<dd><p>Estimate class prevalence values using the best model found after calling the <a class="reference internal" href="#quapy.model_selection.GridSearchQ.fit" title="quapy.model_selection.GridSearchQ.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – sample contanining the instances</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a ndarray of shape <cite>(n_classes)</cite> with class prevalence estimates as according to the best model found
by the model selection process.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.model_selection.GridSearchQ.set_fit_request">
<span class="sig-name descname"><span class="pre">set_fit_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><span class="pre">GridSearchQ</span></a></span></span><a class="headerlink" href="#quapy.model_selection.GridSearchQ.set_fit_request" title="Link to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config" title="(in scikit-learn v1.5)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code></a>).
Please see <a class="reference external" href="https://scikit-learn.org/stable/metadata_routing.html#metadata-routing" title="(in scikit-learn v1.5)"><span class="xref std std-ref">User Guide</span></a> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">fit</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v1.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>training</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">training</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.model_selection.GridSearchQ.set_params">
<span class="sig-name descname"><span class="pre">set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#GridSearchQ.set_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.GridSearchQ.set_params" title="Link to this definition"></a></dt>
<dd><p>Sets the hyper-parameters to explore.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>parameters</strong> – a dictionary with keys the parameter names and values the list of values to explore</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.model_selection.Status">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.model_selection.</span></span><span class="sig-name descname"><span class="pre">Status</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qualname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#Status"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.Status" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.model_selection.Status.ERROR">
<span class="sig-name descname"><span class="pre">ERROR</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4</span></em><a class="headerlink" href="#quapy.model_selection.Status.ERROR" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.model_selection.Status.INVALID">
<span class="sig-name descname"><span class="pre">INVALID</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#quapy.model_selection.Status.INVALID" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.model_selection.Status.SUCCESS">
<span class="sig-name descname"><span class="pre">SUCCESS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#quapy.model_selection.Status.SUCCESS" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.model_selection.Status.TIMEOUT">
<span class="sig-name descname"><span class="pre">TIMEOUT</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#quapy.model_selection.Status.TIMEOUT" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.model_selection.cross_val_predict">
<span class="sig-prename descclassname"><span class="pre">quapy.model_selection.</span></span><span class="sig-name descname"><span class="pre">cross_val_predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.method.html#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><span class="pre">BaseQuantifier</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfolds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#cross_val_predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.cross_val_predict" title="Link to this definition"></a></dt>
<dd><p>Akin to <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.cross_val_predict.html">scikit-learn’s cross_val_predict</a>
but for quantification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quantifier</strong> – a quantifier issuing class prevalence values</p></li>
<li><p><strong>data</strong> – a labelled collection</p></li>
<li><p><strong>nfolds</strong> – number of folds for k-fold cross validation generation</p></li>
<li><p><strong>random_state</strong> – random seed for reproducibility</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a vector of class prevalence values</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.model_selection.expand_grid">
<span class="sig-prename descclassname"><span class="pre">quapy.model_selection.</span></span><span class="sig-name descname"><span class="pre">expand_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#expand_grid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.expand_grid" title="Link to this definition"></a></dt>
<dd><p>Expands a param_grid dictionary as a list of configurations.
Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">combinations</span> <span class="o">=</span> <span class="n">expand_grid</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">combinations</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>param_grid</strong> – dictionary with keys representing hyper-parameter names, and values representing the range
to explore for that hyper-parameter</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of configurations, i.e., combinations of hyper-parameter assignments in the grid.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.model_selection.group_params">
<span class="sig-prename descclassname"><span class="pre">quapy.model_selection.</span></span><span class="sig-name descname"><span class="pre">group_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/model_selection.html#group_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.model_selection.group_params" title="Link to this definition"></a></dt>
<dd><p>Partitions a param_grid dictionary as two lists of configurations, one for the classifier-specific
hyper-parameters, and another for que quantifier-specific hyper-parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>param_grid</strong> – dictionary with keys representing hyper-parameter names, and values representing the range
to explore for that hyper-parameter</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>two expanded grids of configurations, one for the classifier, another for the quantifier</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-quapy.plot">
<span id="quapy-plot-module"></span><h2>quapy.plot module<a class="headerlink" href="#module-quapy.plot" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="quapy.plot.binary_bias_bins">
<span class="sig-prename descclassname"><span class="pre">quapy.plot.</span></span><span class="sig-name descname"><span class="pre">binary_bias_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">true_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estim_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_class=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins=5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colormap=&lt;matplotlib.colors.ListedColormap</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertical_xticks=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">savepath=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/plot.html#binary_bias_bins"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.plot.binary_bias_bins" title="Link to this definition"></a></dt>
<dd><p>Box-plots displaying the local bias (i.e., signed error computed as the estimated value minus the true value)
for different bins of (true) prevalence of the positive classs, for each quantification method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method_names</strong> – array-like with the method names for each experiment</p></li>
<li><p><strong>true_prevs</strong> – array-like with the true prevalence values (each being a ndarray with n_classes components) for
each experiment</p></li>
<li><p><strong>estim_prevs</strong> – array-like with the estimated prevalence values (each being a ndarray with n_classes components)
for each experiment</p></li>
<li><p><strong>pos_class</strong> – index of the positive class</p></li>
<li><p><strong>title</strong> – the title to be displayed in the plot</p></li>
<li><p><strong>nbins</strong> – number of bins</p></li>
<li><p><strong>colormap</strong> – the matplotlib colormap to use (default cm.tab10)</p></li>
<li><p><strong>vertical_xticks</strong> – whether or not to add secondary grid (default is False)</p></li>
<li><p><strong>legend</strong> – whether or not to display the legend (default is True)</p></li>
<li><p><strong>savepath</strong> – path where to save the plot. If not indicated (as default), the plot is shown.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.plot.binary_bias_global">
<span class="sig-prename descclassname"><span class="pre">quapy.plot.</span></span><span class="sig-name descname"><span class="pre">binary_bias_global</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">true_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estim_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_class</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">savepath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/plot.html#binary_bias_global"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.plot.binary_bias_global" title="Link to this definition"></a></dt>
<dd><p>Box-plots displaying the global bias (i.e., signed error computed as the estimated value minus the true value)
for each quantification method with respect to a given positive class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method_names</strong> – array-like with the method names for each experiment</p></li>
<li><p><strong>true_prevs</strong> – array-like with the true prevalence values (each being a ndarray with n_classes components) for
each experiment</p></li>
<li><p><strong>estim_prevs</strong> – array-like with the estimated prevalence values (each being a ndarray with n_classes components)
for each experiment</p></li>
<li><p><strong>pos_class</strong> – index of the positive class</p></li>
<li><p><strong>title</strong> – the title to be displayed in the plot</p></li>
<li><p><strong>savepath</strong> – path where to save the plot. If not indicated (as default), the plot is shown.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.plot.binary_diagonal">
<span class="sig-prename descclassname"><span class="pre">quapy.plot.</span></span><span class="sig-name descname"><span class="pre">binary_diagonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">true_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estim_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_class</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_prev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">savepath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/plot.html#binary_diagonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.plot.binary_diagonal" title="Link to this definition"></a></dt>
<dd><p>The diagonal plot displays the predicted prevalence values (along the y-axis) as a function of the true prevalence
values (along the x-axis). The optimal quantifier is described by the diagonal (0,0)-(1,1) of the plot (hence the
name). It is convenient for binary quantification problems, though it can be used for multiclass problems by
indicating which class is to be taken as the positive class. (For multiclass quantification problems, other plots
like the <a class="reference internal" href="#quapy.plot.error_by_drift" title="quapy.plot.error_by_drift"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error_by_drift()</span></code></a> might be preferable though).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method_names</strong> – array-like with the method names for each experiment</p></li>
<li><p><strong>true_prevs</strong> – array-like with the true prevalence values (each being a ndarray with n_classes components) for
each experiment</p></li>
<li><p><strong>estim_prevs</strong> – array-like with the estimated prevalence values (each being a ndarray with n_classes components)
for each experiment</p></li>
<li><p><strong>pos_class</strong> – index of the positive class</p></li>
<li><p><strong>title</strong> – the title to be displayed in the plot</p></li>
<li><p><strong>show_std</strong> – whether or not to show standard deviations (represented by color bands). This might be inconvenient
for cases in which many methods are compared, or when the standard deviations are high – default True)</p></li>
<li><p><strong>legend</strong> – whether or not to display the leyend (default True)</p></li>
<li><p><strong>train_prev</strong> – if indicated (default is None), the training prevalence (for the positive class) is hightlighted
in the plot. This is convenient when all the experiments have been conducted in the same dataset.</p></li>
<li><p><strong>savepath</strong> – path where to save the plot. If not indicated (as default), the plot is shown.</p></li>
<li><p><strong>method_order</strong> – if indicated (default is None), imposes the order in which the methods are processed (i.e.,
listed in the legend and associated with matplotlib colors).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.plot.brokenbar_supremacy_by_drift">
<span class="sig-prename descclassname"><span class="pre">quapy.plot.</span></span><span class="sig-name descname"><span class="pre">brokenbar_supremacy_by_drift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">true_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estim_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'isomerous'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ae'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ae'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ttest_alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail_density_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">savepath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/plot.html#brokenbar_supremacy_by_drift"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.plot.brokenbar_supremacy_by_drift" title="Link to this definition"></a></dt>
<dd><p>Displays (only) the top performing methods for different regions of the train-test shift in form of a broken
bar chart, in which each method has bars only for those regions in which either one of the following conditions
hold: (i) it is the best method (in average) for the bin, or (ii) it is not statistically significantly different
(in average) as according to a two-sided t-test on independent samples at confidence <cite>ttest_alpha</cite>.
The binning can be made “isometric” (same size), or “isomerous” (same number of experiments – default). A second
plot is displayed on top, that displays the distribution of experiments for each bin (when binning=”isometric”) or
the percentiles points of the distribution (when binning=”isomerous”).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method_names</strong> – array-like with the method names for each experiment</p></li>
<li><p><strong>true_prevs</strong> – array-like with the true prevalence values (each being a ndarray with n_classes components) for
each experiment</p></li>
<li><p><strong>estim_prevs</strong> – array-like with the estimated prevalence values (each being a ndarray with n_classes components)
for each experiment</p></li>
<li><p><strong>tr_prevs</strong> – training prevalence of each experiment</p></li>
<li><p><strong>n_bins</strong> – number of bins in which the y-axis is to be divided (default is 20)</p></li>
<li><p><strong>binning</strong> – type of binning, either “isomerous” (default) or “isometric”</p></li>
<li><p><strong>x_error</strong> – a string representing the name of an error function (as defined in <cite>quapy.error</cite>) to be used for
measuring the amount of train-test shift (default is “ae”)</p></li>
<li><p><strong>y_error</strong> – a string representing the name of an error function (as defined in <cite>quapy.error</cite>) to be used for
measuring the amount of error in the prevalence estimations (default is “ae”)</p></li>
<li><p><strong>ttest_alpha</strong> – the confidence interval above which a p-value (two-sided t-test on independent samples) is
to be considered as an indicator that the two means are not statistically significantly different. Default is
0.005, meaning that a <cite>p-value &gt; 0.005</cite> indicates the two methods involved are to be considered similar</p></li>
<li><p><strong>tail_density_threshold</strong> – sets a threshold on the density of experiments (over the total number of experiments)
below which a bin in the tail (i.e., the right-most ones) will be discarded. This is in order to avoid some
bins to be shown for train-test outliers.</p></li>
<li><p><strong>method_order</strong> – if indicated (default is None), imposes the order in which the methods are processed (i.e.,
listed in the legend and associated with matplotlib colors).</p></li>
<li><p><strong>savepath</strong> – path where to save the plot. If not indicated (as default), the plot is shown.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.plot.error_by_drift">
<span class="sig-prename descclassname"><span class="pre">quapy.plot.</span></span><span class="sig-name descname"><span class="pre">error_by_drift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">true_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estim_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr_prevs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ae'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_legend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Quantification</span> <span class="pre">error</span> <span class="pre">as</span> <span class="pre">a</span> <span class="pre">function</span> <span class="pre">of</span> <span class="pre">distribution</span> <span class="pre">shift'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vlines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">savepath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/plot.html#error_by_drift"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.plot.error_by_drift" title="Link to this definition"></a></dt>
<dd><p>Plots the error (along the x-axis, as measured in terms of <cite>error_name</cite>) as a function of the train-test shift
(along the y-axis, as measured in terms of <a class="reference internal" href="#quapy.error.ae" title="quapy.error.ae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.ae()</span></code></a>). This plot is useful especially for multiclass
problems, in which “diagonal plots” may be cumbersone, and in order to gain understanding about how methods
fare in different regions of the prior probability shift spectrum (e.g., in the low-shift regime vs. in the
high-shift regime).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method_names</strong> – array-like with the method names for each experiment</p></li>
<li><p><strong>true_prevs</strong> – array-like with the true prevalence values (each being a ndarray with n_classes components) for
each experiment</p></li>
<li><p><strong>estim_prevs</strong> – array-like with the estimated prevalence values (each being a ndarray with n_classes components)
for each experiment</p></li>
<li><p><strong>tr_prevs</strong> – training prevalence of each experiment</p></li>
<li><p><strong>n_bins</strong> – number of bins in which the y-axis is to be divided (default is 20)</p></li>
<li><p><strong>error_name</strong> – a string representing the name of an error function (as defined in <cite>quapy.error</cite>, default is “ae”)</p></li>
<li><p><strong>show_std</strong> – whether or not to show standard deviations as color bands (default is False)</p></li>
<li><p><strong>show_density</strong> – whether or not to display the distribution of experiments for each bin (default is True)</p></li>
<li><p><strong>show_density</strong> – whether or not to display the legend of the chart (default is True)</p></li>
<li><p><strong>logscale</strong> – whether or not to log-scale the y-error measure (default is False)</p></li>
<li><p><strong>title</strong> – title of the plot (default is “Quantification error as a function of distribution shift”)</p></li>
<li><p><strong>vlines</strong> – array-like list of values (default is None). If indicated, highlights some regions of the space
using vertical dotted lines.</p></li>
<li><p><strong>method_order</strong> – if indicated (default is None), imposes the order in which the methods are processed (i.e.,
listed in the legend and associated with matplotlib colors).</p></li>
<li><p><strong>savepath</strong> – path where to save the plot. If not indicated (as default), the plot is shown.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-quapy.protocol">
<span id="quapy-protocol-module"></span><h2>quapy.protocol module<a class="headerlink" href="#module-quapy.protocol" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="quapy.protocol.APP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.protocol.</span></span><span class="sig-name descname"><span class="pre">APP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_prevalences</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">21</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_limits_epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sanity_check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sample_prev'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#APP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.APP" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.protocol.AbstractStochasticSeededProtocol" title="quapy.protocol.AbstractStochasticSeededProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractStochasticSeededProtocol</span></code></a>, <a class="reference internal" href="#quapy.protocol.OnLabelledCollectionProtocol" title="quapy.protocol.OnLabelledCollectionProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">OnLabelledCollectionProtocol</span></code></a></p>
<p>Implementation of the artificial prevalence protocol (APP).
The APP consists of exploring a grid of prevalence values containing <cite>n_prevalences</cite> points (e.g.,
[0, 0.05, 0.1, 0.15, …, 1], if <cite>n_prevalences=21</cite>), and generating all valid combinations of
prevalence values for all classes (e.g., for 3 classes, samples with [0, 0, 1], [0, 0.05, 0.95], …,
[1, 0, 0] prevalence values of size <cite>sample_size</cite> will be yielded). The number of samples for each valid
combination of prevalence values is indicated by <cite>repeats</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – a <cite>LabelledCollection</cite> from which the samples will be drawn</p></li>
<li><p><strong>sample_size</strong> – integer, number of instances in each sample; if None (default) then it is taken from
qp.environ[“SAMPLE_SIZE”]. If this is not set, a ValueError exception is raised.</p></li>
<li><p><strong>n_prevalences</strong> – the number of equidistant prevalence points to extract from the [0,1] interval for the
grid (default is 21)</p></li>
<li><p><strong>repeats</strong> – number of copies for each valid prevalence vector (default is 10)</p></li>
<li><p><strong>smooth_limits_epsilon</strong> – the quantity to add and subtract to the limits 0 and 1</p></li>
<li><p><strong>random_state</strong> – allows replicating samples across runs (default 0, meaning that the sequence of samples
will be the same every time the protocol is called)</p></li>
<li><p><strong>sanity_check</strong> – int, raises an exception warning the user that the number of examples to be generated exceed
this number; set to None for skipping this check</p></li>
<li><p><strong>return_type</strong> – set to “sample_prev” (default) to get the pairs of (sample, prevalence) at each iteration, or
to “labelled_collection” to get instead instances of LabelledCollection</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.APP.prevalence_grid">
<span class="sig-name descname"><span class="pre">prevalence_grid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#APP.prevalence_grid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.APP.prevalence_grid" title="Link to this definition"></a></dt>
<dd><p>Generates vectors of prevalence values from an exhaustive grid of prevalence values. The
number of prevalence values explored for each dimension depends on <cite>n_prevalences</cite>, so that, if, for example,
<cite>n_prevalences=11</cite> then the prevalence values of the grid are taken from [0, 0.1, 0.2, …, 0.9, 1]. Only
valid prevalence distributions are returned, i.e., vectors of prevalence values that sum up to 1. For each
valid vector of prevalence values, <cite>repeat</cite> copies are returned. The vector of prevalence values can be
implicit (by setting <cite>return_constrained_dim=False</cite>), meaning that the last dimension (which is constrained
to 1 - sum of the rest) is not returned (note that, quite obviously, in this case the vector does not sum up to
1). Note that this method is deterministic, i.e., there is no random sampling anywhere.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a <cite>np.ndarray</cite> of shape <cite>(n, dimensions)</cite> if <cite>return_constrained_dim=True</cite> or of shape
<cite>(n, dimensions-1)</cite> if <cite>return_constrained_dim=False</cite>, where <cite>n</cite> is the number of valid combinations found
in the grid multiplied by <cite>repeat</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.APP.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#APP.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.APP.sample" title="Link to this definition"></a></dt>
<dd><p>Realizes the sample given the index of the instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>index</strong> – indexes of the instances to select</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">qp.data.LabelledCollection</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.APP.samples_parameters">
<span class="sig-name descname"><span class="pre">samples_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#APP.samples_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.APP.samples_parameters" title="Link to this definition"></a></dt>
<dd><p>Return all the necessary parameters to replicate the samples as according to the APP protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a list of indexes that realize the APP sampling</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.APP.total">
<span class="sig-name descname"><span class="pre">total</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#APP.total"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.APP.total" title="Link to this definition"></a></dt>
<dd><p>Returns the number of samples that will be generated</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.protocol.AbstractProtocol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.protocol.</span></span><span class="sig-name descname"><span class="pre">AbstractProtocol</span></span><a class="reference internal" href="_modules/quapy/protocol.html#AbstractProtocol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.AbstractProtocol" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract parent class for sample generation protocols.</p>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.AbstractProtocol.total">
<span class="sig-name descname"><span class="pre">total</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#AbstractProtocol.total"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.AbstractProtocol.total" title="Link to this definition"></a></dt>
<dd><p>Indicates the total number of samples that the protocol generates.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of samples to generate if known, or <cite>None</cite> otherwise.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.protocol.AbstractStochasticSeededProtocol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.protocol.</span></span><span class="sig-name descname"><span class="pre">AbstractStochasticSeededProtocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#AbstractStochasticSeededProtocol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.AbstractStochasticSeededProtocol" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.protocol.AbstractProtocol" title="quapy.protocol.AbstractProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractProtocol</span></code></a></p>
<p>An <cite>AbstractStochasticSeededProtocol</cite> is a protocol that generates, via any random procedure (e.g.,
via random sampling), sequences of <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> samples.
The protocol abstraction enforces
the object to be instantiated using a seed, so that the sequence can be fully replicated.
In order to make this functionality possible, the classes extending this abstraction need to
implement only two functions, <a class="reference internal" href="#quapy.protocol.AbstractStochasticSeededProtocol.samples_parameters" title="quapy.protocol.AbstractStochasticSeededProtocol.samples_parameters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">samples_parameters()</span></code></a> which generates all the parameters
needed for extracting the samples, and <a class="reference internal" href="#quapy.protocol.AbstractStochasticSeededProtocol.sample" title="quapy.protocol.AbstractStochasticSeededProtocol.sample"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sample()</span></code></a> that, given some parameters as input,
deterministically generates a sample.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>random_state</strong> – the seed for allowing to replicate any sequence of samples. Default is 0, meaning that
the sequence will be consistent every time the protocol is called.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.AbstractStochasticSeededProtocol.collator">
<span class="sig-name descname"><span class="pre">collator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#AbstractStochasticSeededProtocol.collator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.AbstractStochasticSeededProtocol.collator" title="Link to this definition"></a></dt>
<dd><p>The collator prepares the sample to accommodate the desired output format before returning the output.
This collator simply returns the sample as it is. Classes inheriting from this abstract class can
implement their custom collators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample</strong> – the sample to be returned</p></li>
<li><p><strong>args</strong> – additional arguments</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the sample adhering to a desired output format (in this case, the sample is returned as it is)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="quapy.protocol.AbstractStochasticSeededProtocol.random_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random_state</span></span><a class="headerlink" href="#quapy.protocol.AbstractStochasticSeededProtocol.random_state" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.AbstractStochasticSeededProtocol.sample">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#AbstractStochasticSeededProtocol.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.AbstractStochasticSeededProtocol.sample" title="Link to this definition"></a></dt>
<dd><p>Extract one sample determined by the given parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>params</strong> – all the necessary parameters to generate a sample</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>one sample (the same sample has to be generated for the same parameters)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.AbstractStochasticSeededProtocol.samples_parameters">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">samples_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#AbstractStochasticSeededProtocol.samples_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.AbstractStochasticSeededProtocol.samples_parameters" title="Link to this definition"></a></dt>
<dd><p>This function has to return all the necessary parameters to replicate the samples</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a list of parameters, each of which serves to deterministically generate a sample</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.protocol.ArtificialPrevalenceProtocol">
<span class="sig-prename descclassname"><span class="pre">quapy.protocol.</span></span><span class="sig-name descname"><span class="pre">ArtificialPrevalenceProtocol</span></span><a class="headerlink" href="#quapy.protocol.ArtificialPrevalenceProtocol" title="Link to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.protocol.APP" title="quapy.protocol.APP"><code class="xref py py-class docutils literal notranslate"><span class="pre">APP</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.protocol.DomainMixer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.protocol.</span></span><span class="sig-name descname"><span class="pre">DomainMixer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domainA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">domainB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevalence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mixture_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sample_prev'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#DomainMixer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.DomainMixer" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.protocol.AbstractStochasticSeededProtocol" title="quapy.protocol.AbstractStochasticSeededProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractStochasticSeededProtocol</span></code></a></p>
<p>Generates mixtures of two domains (A and B) at controlled rates, but preserving the original class prevalence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domainA</strong> – one domain, an object of <code class="xref py py-class docutils literal notranslate"><span class="pre">qp.data.LabelledCollection</span></code></p></li>
<li><p><strong>domainB</strong> – another domain, an object of <code class="xref py py-class docutils literal notranslate"><span class="pre">qp.data.LabelledCollection</span></code></p></li>
<li><p><strong>sample_size</strong> – integer, the number of instances in each sample; if None (default) then it is taken from
qp.environ[“SAMPLE_SIZE”]. If this is not set, a ValueError exception is raised.</p></li>
<li><p><strong>repeats</strong> – int, number of samples to draw for every mixture rate</p></li>
<li><p><strong>prevalence</strong> – the prevalence to preserv along the mixtures. If specified, should be an array containing
one prevalence value (positive float) for each class and summing up to one. If not specified, the prevalence
will be taken from the domain A (default).</p></li>
<li><p><strong>mixture_points</strong> – an integer indicating the number of points to take from a linear scale (e.g., 21 will
generate the mixture points [1, 0.95, 0.9, …, 0]), or the array of mixture values itself.
the specific points</p></li>
<li><p><strong>random_state</strong> – allows replicating samples across runs (default 0, meaning that the sequence of samples
will be the same every time the protocol is called)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.DomainMixer.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indexes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#DomainMixer.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.DomainMixer.sample" title="Link to this definition"></a></dt>
<dd><p>Realizes the sample given a pair of indexes of the instances from A and B.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>indexes</strong> – indexes of the instances to select from A and B</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">qp.data.LabelledCollection</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.DomainMixer.samples_parameters">
<span class="sig-name descname"><span class="pre">samples_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#DomainMixer.samples_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.DomainMixer.samples_parameters" title="Link to this definition"></a></dt>
<dd><p>Return all the necessary parameters to replicate the samples as according to the this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a list of zipped indexes (from A and B) that realize the sampling</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.DomainMixer.total">
<span class="sig-name descname"><span class="pre">total</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#DomainMixer.total"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.DomainMixer.total" title="Link to this definition"></a></dt>
<dd><p>Returns the number of samples that will be generated (equals to “repeats * mixture_points”)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.protocol.IterateProtocol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.protocol.</span></span><span class="sig-name descname"><span class="pre">IterateProtocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">samples:</span> <span class="pre">[&lt;class</span> <span class="pre">'quapy.data.base.LabelledCollection'&gt;]</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#IterateProtocol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.IterateProtocol" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.protocol.AbstractProtocol" title="quapy.protocol.AbstractProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractProtocol</span></code></a></p>
<p>A very simple protocol which simply iterates over a list of previously generated samples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>samples</strong> – a list of <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a></p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.IterateProtocol.total">
<span class="sig-name descname"><span class="pre">total</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#IterateProtocol.total"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.IterateProtocol.total" title="Link to this definition"></a></dt>
<dd><p>Returns the number of samples in this protocol</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.protocol.NPP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.protocol.</span></span><span class="sig-name descname"><span class="pre">NPP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sample_prev'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#NPP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.NPP" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.protocol.AbstractStochasticSeededProtocol" title="quapy.protocol.AbstractStochasticSeededProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractStochasticSeededProtocol</span></code></a>, <a class="reference internal" href="#quapy.protocol.OnLabelledCollectionProtocol" title="quapy.protocol.OnLabelledCollectionProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">OnLabelledCollectionProtocol</span></code></a></p>
<p>A generator of samples that implements the natural prevalence protocol (NPP). The NPP consists of drawing
samples uniformly at random, therefore approximately preserving the natural prevalence of the collection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – a <cite>LabelledCollection</cite> from which the samples will be drawn</p></li>
<li><p><strong>sample_size</strong> – integer, the number of instances in each sample; if None (default) then it is taken from
qp.environ[“SAMPLE_SIZE”]. If this is not set, a ValueError exception is raised.</p></li>
<li><p><strong>repeats</strong> – the number of samples to generate. Default is 100.</p></li>
<li><p><strong>random_state</strong> – allows replicating samples across runs (default 0, meaning that the sequence of samples
will be the same every time the protocol is called)</p></li>
<li><p><strong>return_type</strong> – set to “sample_prev” (default) to get the pairs of (sample, prevalence) at each iteration, or
to “labelled_collection” to get instead instances of LabelledCollection</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.NPP.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#NPP.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.NPP.sample" title="Link to this definition"></a></dt>
<dd><p>Realizes the sample given the index of the instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>index</strong> – indexes of the instances to select</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">qp.data.LabelledCollection</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.NPP.samples_parameters">
<span class="sig-name descname"><span class="pre">samples_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#NPP.samples_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.NPP.samples_parameters" title="Link to this definition"></a></dt>
<dd><p>Return all the necessary parameters to replicate the samples as according to the NPP protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a list of indexes that realize the NPP sampling</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.NPP.total">
<span class="sig-name descname"><span class="pre">total</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#NPP.total"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.NPP.total" title="Link to this definition"></a></dt>
<dd><p>Returns the number of samples that will be generated (equals to “repeats”)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.protocol.NaturalPrevalenceProtocol">
<span class="sig-prename descclassname"><span class="pre">quapy.protocol.</span></span><span class="sig-name descname"><span class="pre">NaturalPrevalenceProtocol</span></span><a class="headerlink" href="#quapy.protocol.NaturalPrevalenceProtocol" title="Link to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.protocol.NPP" title="quapy.protocol.NPP"><code class="xref py py-class docutils literal notranslate"><span class="pre">NPP</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.protocol.OnLabelledCollectionProtocol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.protocol.</span></span><span class="sig-name descname"><span class="pre">OnLabelledCollectionProtocol</span></span><a class="reference internal" href="_modules/quapy/protocol.html#OnLabelledCollectionProtocol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.OnLabelledCollectionProtocol" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Protocols that generate samples from a <code class="xref py py-class docutils literal notranslate"><span class="pre">qp.data.LabelledCollection</span></code> object.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.protocol.OnLabelledCollectionProtocol.RETURN_TYPES">
<span class="sig-name descname"><span class="pre">RETURN_TYPES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['sample_prev',</span> <span class="pre">'labelled_collection',</span> <span class="pre">'index']</span></em><a class="headerlink" href="#quapy.protocol.OnLabelledCollectionProtocol.RETURN_TYPES" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.OnLabelledCollectionProtocol.get_collator">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_collator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sample_prev'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#OnLabelledCollectionProtocol.get_collator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.OnLabelledCollectionProtocol.get_collator" title="Link to this definition"></a></dt>
<dd><p>Returns a collator function, i.e., a function that prepares the yielded data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_type</strong> – either ‘sample_prev’ (default) if the collator is requested to yield tuples of
<cite>(sample, prevalence)</cite>, or ‘labelled_collection’ when it is requested to yield instances of
<code class="xref py py-class docutils literal notranslate"><span class="pre">qp.data.LabelledCollection</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the collator function (a callable function that takes as input an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">qp.data.LabelledCollection</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.OnLabelledCollectionProtocol.get_labelled_collection">
<span class="sig-name descname"><span class="pre">get_labelled_collection</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#OnLabelledCollectionProtocol.get_labelled_collection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.OnLabelledCollectionProtocol.get_labelled_collection" title="Link to this definition"></a></dt>
<dd><p>Returns the labelled collection on which this protocol acts.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>an object of type <code class="xref py py-class docutils literal notranslate"><span class="pre">qp.data.LabelledCollection</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.OnLabelledCollectionProtocol.on_preclassified_instances">
<span class="sig-name descname"><span class="pre">on_preclassified_instances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pre_classifications</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_place</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#OnLabelledCollectionProtocol.on_preclassified_instances"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.OnLabelledCollectionProtocol.on_preclassified_instances" title="Link to this definition"></a></dt>
<dd><p>Returns a copy of this protocol that acts on a modified version of the original
<code class="xref py py-class docutils literal notranslate"><span class="pre">qp.data.LabelledCollection</span></code> in which the original instances have been replaced
with the outputs of a classifier for each instance. (This is convenient for speeding-up
the evaluation procedures for many samples, by pre-classifying the instances in advance.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pre_classifications</strong> – the predictions issued by a classifier, typically an array-like
with shape <cite>(n_instances,)</cite> when the classifier is a hard one, or with shape
<cite>(n_instances, n_classes)</cite> when the classifier is a probabilistic one.</p></li>
<li><p><strong>in_place</strong> – whether or not to apply the modification in-place or in a new copy (default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a copy of this protocol</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.protocol.UPP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.protocol.</span></span><span class="sig-name descname"><span class="pre">UPP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sample_prev'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#UPP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.UPP" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.protocol.AbstractStochasticSeededProtocol" title="quapy.protocol.AbstractStochasticSeededProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractStochasticSeededProtocol</span></code></a>, <a class="reference internal" href="#quapy.protocol.OnLabelledCollectionProtocol" title="quapy.protocol.OnLabelledCollectionProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">OnLabelledCollectionProtocol</span></code></a></p>
<p>A variant of <a class="reference internal" href="#quapy.protocol.APP" title="quapy.protocol.APP"><code class="xref py py-class docutils literal notranslate"><span class="pre">APP</span></code></a> that, instead of using a grid of equidistant prevalence values,
relies on the Kraemer algorithm for sampling unit (k-1)-simplex uniformly at random, with
k the number of classes. This protocol covers the entire range of prevalence values in a
statistical sense, i.e., unlike APP there is no guarantee that it is covered precisely
equally for all classes, but it is preferred in cases in which the number of possible
combinations of the grid values of APP makes this endeavour intractable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – a <cite>LabelledCollection</cite> from which the samples will be drawn</p></li>
<li><p><strong>sample_size</strong> – integer, the number of instances in each sample; if None (default) then it is taken from
qp.environ[“SAMPLE_SIZE”]. If this is not set, a ValueError exception is raised.</p></li>
<li><p><strong>repeats</strong> – the number of samples to generate. Default is 100.</p></li>
<li><p><strong>random_state</strong> – allows replicating samples across runs (default 0, meaning that the sequence of samples
will be the same every time the protocol is called)</p></li>
<li><p><strong>return_type</strong> – set to “sample_prev” (default) to get the pairs of (sample, prevalence) at each iteration, or
to “labelled_collection” to get instead instances of LabelledCollection</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.UPP.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#UPP.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.UPP.sample" title="Link to this definition"></a></dt>
<dd><p>Realizes the sample given the index of the instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>index</strong> – indexes of the instances to select</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">qp.data.LabelledCollection</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.UPP.samples_parameters">
<span class="sig-name descname"><span class="pre">samples_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#UPP.samples_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.UPP.samples_parameters" title="Link to this definition"></a></dt>
<dd><p>Return all the necessary parameters to replicate the samples as according to the UPP protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a list of indexes that realize the UPP sampling</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.protocol.UPP.total">
<span class="sig-name descname"><span class="pre">total</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/protocol.html#UPP.total"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.protocol.UPP.total" title="Link to this definition"></a></dt>
<dd><p>Returns the number of samples that will be generated (equals to “repeats”)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.protocol.UniformPrevalenceProtocol">
<span class="sig-prename descclassname"><span class="pre">quapy.protocol.</span></span><span class="sig-name descname"><span class="pre">UniformPrevalenceProtocol</span></span><a class="headerlink" href="#quapy.protocol.UniformPrevalenceProtocol" title="Link to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.protocol.UPP" title="quapy.protocol.UPP"><code class="xref py py-class docutils literal notranslate"><span class="pre">UPP</span></code></a></p>
</dd></dl>

</section>
<section id="module-quapy.util">
<span id="quapy-util-module"></span><h2>quapy.util module<a class="headerlink" href="#module-quapy.util" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="quapy.util.EarlyStop">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">EarlyStop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">patience</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_is_better</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#EarlyStop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.EarlyStop" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class implementing the early-stopping condition typically used for training neural networks.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">earlystop</span> <span class="o">=</span> <span class="n">EarlyStop</span><span class="p">(</span><span class="n">patience</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lower_is_better</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">earlystop</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">earlystop</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">earlystop</span><span class="o">.</span><span class="n">IMPROVED</span>  <span class="c1"># is True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">earlystop</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">earlystop</span><span class="o">.</span><span class="n">STOP</span>  <span class="c1"># is False (patience=1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">earlystop</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">earlystop</span><span class="o">.</span><span class="n">STOP</span>  <span class="c1"># is True (patience=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">earlystop</span><span class="o">.</span><span class="n">best_epoch</span>  <span class="c1"># is 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">earlystop</span><span class="o">.</span><span class="n">best_score</span>  <span class="c1"># is 0.7</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>patience</strong> – the number of (consecutive) times that a monitored evaluation metric (typically obtaind in a
held-out validation split) can be found to be worse than the best one obtained so far, before flagging the
stopping condition. An instance of this class is <cite>callable</cite>, and is to be used as follows:</p></li>
<li><p><strong>lower_is_better</strong> – if True (default) the metric is to be minimized.</p></li>
</ul>
</dd>
<dt class="field-even">Variables<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>best_score</strong> – keeps track of the best value seen so far</p></li>
<li><p><strong>best_epoch</strong> – keeps track of the epoch in which the best score was set</p></li>
<li><p><strong>STOP</strong> – flag (boolean) indicating the stopping condition</p></li>
<li><p><strong>IMPROVED</strong> – flag (boolean) indicating whether there was an improvement in the last call</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.create_if_not_exist">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">create_if_not_exist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#create_if_not_exist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.create_if_not_exist" title="Link to this definition"></a></dt>
<dd><p>An alias to <cite>os.makedirs(path, exist_ok=True)</cite> that also returns the path. This is useful in cases like, e.g.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">create_if_not_exist</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">subdir</span><span class="p">,</span> <span class="n">anotherdir</span><span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> – path to create</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the path itself</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.create_parent_dir">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">create_parent_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#create_parent_dir"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.create_parent_dir" title="Link to this definition"></a></dt>
<dd><p>Creates the parent dir (if any) of a given path, if not exists. E.g., for <cite>./path/to/file.txt</cite>, the path <cite>./path/to</cite>
is created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> – the path</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.download_file">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">download_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">archive_filename</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#download_file"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.download_file" title="Link to this definition"></a></dt>
<dd><p>Downloads a file from a url</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>url</strong> – the url</p></li>
<li><p><strong>archive_filename</strong> – destination filename</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.download_file_if_not_exists">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">download_file_if_not_exists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">archive_filename</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#download_file_if_not_exists"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.download_file_if_not_exists" title="Link to this definition"></a></dt>
<dd><p>Dowloads a function (using <a class="reference internal" href="#quapy.util.download_file" title="quapy.util.download_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">download_file()</span></code></a>) if the file does not exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>url</strong> – the url</p></li>
<li><p><strong>archive_filename</strong> – destination filename</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.get_quapy_home">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">get_quapy_home</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#get_quapy_home"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.get_quapy_home" title="Link to this definition"></a></dt>
<dd><p>Gets the home directory of QuaPy, i.e., the directory where QuaPy saves permanent data, such as dowloaded datasets.
This directory is <cite>~/quapy_data</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a string representing the path</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.load_report">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">load_report</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#load_report"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.load_report" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.map_parallel">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">map_parallel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#map_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.map_parallel" title="Link to this definition"></a></dt>
<dd><p>Applies func to n_jobs slices of args. E.g., if args is an array of 99 items and n_jobs=2, then
func is applied in two parallel processes to args[0:50] and to args[50:99]. func is a function
that already works with a list of arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function to be parallelized</p></li>
<li><p><strong>args</strong> – array-like of arguments to be passed to the function in different parallel calls</p></li>
<li><p><strong>n_jobs</strong> – the number of workers</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.parallel">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">parallel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">asarray</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'loky'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.parallel" title="Link to this definition"></a></dt>
<dd><p>A wrapper of multiprocessing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">delayed</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">args_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">args_i</span> <span class="ow">in</span> <span class="n">args</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
</pre></div>
</div>
<p>that takes the <cite>quapy.environ</cite> variable as input silently.
Seeds the child processes to ensure reproducibility when n_jobs&gt;1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – callable</p></li>
<li><p><strong>args</strong> – args of func</p></li>
<li><p><strong>seed</strong> – the numeric seed</p></li>
<li><p><strong>asarray</strong> – set to True to return a np.ndarray instead of a list</p></li>
<li><p><strong>backend</strong> – indicates the backend used for handling parallel works</p></li>
<li><p><strong>open_args</strong> – if True, then the delayed function is called on <a href="#id8"><span class="problematic" id="id9">*</span></a>args_i, instead of on args_i</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.parallel_unpack">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">parallel_unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">asarray</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'loky'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#parallel_unpack"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.parallel_unpack" title="Link to this definition"></a></dt>
<dd><p>A wrapper of multiprocessing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">delayed</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="o">*</span><span class="n">args_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">args_i</span> <span class="ow">in</span> <span class="n">args</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
</pre></div>
</div>
<p>that takes the <cite>quapy.environ</cite> variable as input silently.
Seeds the child processes to ensure reproducibility when n_jobs&gt;1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – callable</p></li>
<li><p><strong>args</strong> – args of func</p></li>
<li><p><strong>seed</strong> – the numeric seed</p></li>
<li><p><strong>asarray</strong> – set to True to return a np.ndarray instead of a list</p></li>
<li><p><strong>backend</strong> – indicates the backend used for handling parallel works</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.pickled_resource">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">pickled_resource</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pickle_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generation_func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#pickled_resource"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.pickled_resource" title="Link to this definition"></a></dt>
<dd><p>Allows for fast reuse of resources that are generated only once by calling generation_func(*args). The next times
this function is invoked, it loads the pickled resource. Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">some_array</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>  <span class="c1"># a mock resource created with one parameter (`n`)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickled_resource</span><span class="p">(</span><span class="s1">&#39;./my_array.pkl&#39;</span><span class="p">,</span> <span class="n">some_array</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c1"># the resource does not exist: it is created by calling some_array(10)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickled_resource</span><span class="p">(</span><span class="s1">&#39;./my_array.pkl&#39;</span><span class="p">,</span> <span class="n">some_array</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c1"># the resource exists; it is loaded from &#39;./my_array.pkl&#39;</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pickle_path</strong> – the path where to save (first time) and load (next times) the resource</p></li>
<li><p><strong>generation_func</strong> – the function that generates the resource, in case it does not exist in pickle_path</p></li>
<li><p><strong>args</strong> – any arg that generation_func uses for generating the resources</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the resource</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.save_text_file">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">save_text_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#save_text_file"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.save_text_file" title="Link to this definition"></a></dt>
<dd><p>Saves a text file to disk, given its full path, and creates the parent directory if missing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – path where to save the path.</p></li>
<li><p><strong>text</strong> – text to save.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.temp_seed">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">temp_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#temp_seed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.temp_seed" title="Link to this definition"></a></dt>
<dd><p>Can be used in a “with” context to set a temporal seed without modifying the outer numpy’s current state. E.g.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">temp_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="k">pass</span> <span class="c1"># do any computation depending on np.random functionality</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>random_state</strong> – the seed to set within the “with” context</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.util.timeout">
<span class="sig-prename descclassname"><span class="pre">quapy.util.</span></span><span class="sig-name descname"><span class="pre">timeout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seconds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quapy/util.html#timeout"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quapy.util.timeout" title="Link to this definition"></a></dt>
<dd><p>Opens a context that will launch an exception if not closed after a given number of seconds</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">start_msg</span><span class="p">,</span> <span class="n">end_msg</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">start_msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">end_msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">timeout</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">func</span><span class="p">(</span><span class="s1">&#39;begin function&#39;</span><span class="p">,</span> <span class="s1">&#39;end function&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Out</span><span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">begin</span> <span class="n">function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="ne">TimeoutError</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>seconds</strong> – number of seconds, set to &lt;=0 to ignore the timer</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-quapy">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-quapy" title="Link to this heading"></a></h2>
<p>QuaPy module for quantification</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="manuals/protocols.html" class="btn btn-neutral float-left" title="7. Protocols" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="quapy.classification.html" class="btn btn-neutral float-right" title="quapy.classification package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Alejandro Moreo.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>